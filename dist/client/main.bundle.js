/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/scripts/classes/PhotonManager.js":
/*!**********************************************!*\
  !*** ./src/scripts/classes/PhotonManager.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PhotonManager\": () => (/* binding */ PhotonManager)\n/* harmony export */ });\nclass PhotonManager {\r\n    constructor() {\r\n        this.photon = new Photon.LoadBalancing.LoadBalancingClient(\r\n            Photon.ConnectionProtocol.Wss,\r\n            '63fffbcc-f982-4abc-96da-992658a15736', // Replace with your Photon App ID\r\n            '1.0' // Version\r\n        );\r\n        this.photon.setLogLevel(Exitgames.Common.Logger.Level.INFO);\r\n        this.photon.onEvent = this.onEvent.bind(this);\r\n        this.photon.onError = this.onError.bind(this);\r\n        this.photon.onStateChange = this.onStateChange.bind(this);\r\n        this.photon.onActorJoin = this.onActorJoin.bind(this);\r\n        this.photon.onActorLeave = this.onActorLeave.bind(this);\r\n        this.photon.onRoomList = this.onRoomList.bind(this);\r\n        this.playerPositions = new Map();\r\n        this.players = new Map();\r\n        this.localPlayerId=0;\r\n\r\n    }\r\n    connect() {\r\n        this.photon.connectToRegionMaster('eu');\r\n    }\r\n    joinOrCreateRoom(roomName) {\r\n        const room = this.roomList.find(room => room.name === roomName);\r\n        if (room) {\r\n            console.log(\"room found, joining\");\r\n            this.photon.joinRoom(roomName);\r\n        } else {\r\n            console.log(\"room not found,creating\");\r\n            this.photon.createRoom(roomName, {\r\n                maxPlayers: 10, broadcastPropsChangeToAll: true\r\n            });\r\n        }\r\n    }\r\n\r\n    sendPlayerPositionUpdate(id, position, rotation, linearVelocity, angularVelocity) {\r\n        this.photon.raiseEvent(1, { id: id, position: position, rotation: rotation, linearVelocity: linearVelocity, angularVelocity:angularVelocity }, { receivers: Photon.LoadBalancing.Constants.ReceiverGroup.Others });\r\n        this.photon.myRoom().setCustomProperties({ [\"pos-\" + id.toString()]: position, [\"rot-\" + id.toString()]: rotation }, { webForward: true });\r\n    }\r\n    setOnPlayerPositionUpdate(callback) {\r\n\r\n        this.onPlayerPositionUpdate = callback;\r\n    }\r\n    setOnJoinedRoom(callback) {\r\n        this.onJoinedRoom = callback;\r\n    }\r\n    onActorJoin(actor) {\r\n        // If the joining actor is the current client, no need to set its custom properties\r\n\r\n        if (this.actorJoinCallback) {\r\n            this.actorJoinCallback(actor);\r\n        }\r\n    }\r\n    onActorLeave(actor) {\r\n        if (this.actorLeaveCallback) {\r\n            this.actorLeaveCallback(actor);\r\n        }\r\n    }\r\n    setOnActorJoin(callback) {\r\n        this.actorJoinCallback = callback;\r\n    }\r\n    setOnActorLeave(callback) {\r\n        this.actorLeaveCallback = callback;\r\n    }\r\n    onEvent(code, data) {\r\n        // Handle Photon events here\r\n    if (code == 1) { // Add this\r\n            \r\n            const { id, position, rotation, linearVelocity, angularVelocity  } = data;\r\n            if(id.toString() !== this.photon.myActor().actorNr.toString()) {\r\n                // Update the position only for remote players\r\n                this.onPlayerPositionUpdate(id,  position, rotation, linearVelocity,angularVelocity);\r\n            }\r\n\r\n        }\r\n       \r\n    }\r\n    onError(errorCode, errorMsg) {\r\n        console.error(`Photon Error: ${errorCode} - ${errorMsg}`);\r\n    }\r\n    onStateChange(state) {\r\n        if (state === Photon.LoadBalancing.LoadBalancingClient.State.JoinedLobby) {\r\n            // this.joinOrCreateRoom('test');\r\n        }\r\n        else if (state === Photon.LoadBalancing.LoadBalancingClient.State.Joined) {\r\n            this.onJoinedRoom();\r\n\r\n        }\r\n    }\r\n    onRoomList(rooms) {\r\n        console.log(rooms);\r\n        this.roomList = rooms;\r\n        this.joinOrCreateRoom(\"test232\");\r\n    }\r\n    getPing() {\r\n        this.photon.updateRtt(\"test232\");\r\n        return this.photon.getRtt();\r\n    }\r\n}\n\n//# sourceURL=webpack://my-app/./src/scripts/classes/PhotonManager.js?");

/***/ }),

/***/ "./src/scripts/classes/Player.js":
/*!***************************************!*\
  !*** ./src/scripts/classes/Player.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Player\": () => (/* binding */ Player)\n/* harmony export */ });\nclass Player {\r\n  constructor(scene, id, isLocal, position = new BABYLON.Vector3(0, 0, 0), rotation=new BABYLON.Quaternion()) {\r\n    console.log(position);\r\n    this.scene = scene;\r\n    this.engine = scene.getEngine();\r\n    this.id = id;\r\n    this.isLocal = isLocal;\r\n    this.position = position;\r\n    this.rotation = rotation;\r\n    this.speed = 0.05;\r\n    this.ZERO_QUATERNION = new BABYLON.Quaternion();\r\n    this.actions = { acceleration: false, braking: false, right: false, left: false, drift: false, boost: false, special: false, special2: false, special3: false };\r\n    this.mesh = null;\r\n    this.positionUpdated=false;\r\n    this.previousState=null;\r\n    this.respawnPosition = position.clone();\r\n    this.advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n    this.specialActive = false;\r\n    this.special2Active = false;\r\n    this.engineForceMultiplier = 1;\r\n    this.lastSpecialTime = 0;\r\n    this.lastSpecial2Time = 0;\r\n    this.lastSpecial3Time = 0;\r\n    this.wheelMeshes = [];\r\n    this.init();\r\n  }\r\n  updateActions(actions) {\r\n    this.actions = actions;\r\n  }\r\n  updatePhysicsBody(position, rotation, linearVelocity, angularVelocity) {\r\n    if (this.body && !this.isLocal) {\r\n      const ammoPosition = new Ammo.btVector3(position._x, position._y, position._z);\r\n      const ammoRotation = new Ammo.btQuaternion(rotation._x, rotation._y, rotation._z, rotation._w);\r\n      const ammoTransform = new Ammo.btTransform();\r\n      ammoTransform.setIdentity();  \r\n      ammoTransform.setOrigin(ammoPosition);\r\n      ammoTransform.setRotation(ammoRotation);\r\n         this.body.setWorldTransform(ammoTransform);\r\n        this.body.setMotionState(new Ammo.btDefaultMotionState(ammoTransform));\r\n         this.body.setLinearVelocity(linearVelocity);\r\n         this.body.setAngularVelocity(angularVelocity);\r\n         this.body.activate();\r\n    //   this.mesh.position.copyFrom(position);\r\n    // this.mesh.rotationQuaternion.copyFrom(rotation);\r\n    } else {\r\n      console.warn(`Attempted to update physics body for player ${this.id} but body is not initialized`);\r\n    }\r\n  }\r\n  updatePhysicsBodyRotation(rotation) {\r\n    if (this.body) {\r\n      const ammoRotation = new Ammo.btQuaternion(rotation.x, rotation.y, rotation.z, rotation.w);\r\n      const ammoTransform = this.body.getCenterOfMassTransform();\r\n      ammoTransform.setRotation(ammoRotation);\r\n      this.body.setCenterOfMassTransform(ammoTransform);\r\n    } else {\r\n      console.warn(`Attempted to update physics body rotation for player ${this.id} but body is not initialized`);\r\n    }\r\n  }\r\n  init() {\r\n    this.mesh = this.createVehicle(this.position, this.rotation);\r\n    this.mesh.position = this.position;\r\n    this.mesh.rotationQuaternion = this.rotation;\r\n    this.positionUpdated = false;\r\n    this.boostParticles = this.createBoostParticles();\r\n    console.log(\"player \" + this.id + \" created\");\r\n    if (this.isLocal) {\r\n      if (/Mobi|Android/i.test(navigator.userAgent)) {\r\n        // Mobile device detected\r\n        this.createJoystick();\r\n        this.createButtons();\r\n        this.setupControls();\r\n      }\r\n      this.createButtons();\r\n      this.createJoystick();\r\n      this.setupControls();\r\n    }\r\n    else {\r\n     // this.mesh.physicsImpostor.setMass(400);\r\n\r\n    }\r\n    var box = new BABYLON.MeshBuilder.CreateBox(\"box\", {width:1, depth:1, height:1}, this.scene);\r\n    box.position.set(1,1,1);\r\n    box.rotation.set(1,1,1);\r\n\r\n        box.position.y += 5;\r\n\r\n    box.physicsImpostor = new BABYLON.PhysicsImpostor(box, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, friction: 0.5, restitution: 0.7 }, this.scene);\r\n    this.mesh.setOr\r\n    return this.mesh;\r\n  }\r\n  \r\n  createJoystick() {\r\n    if(!this.isLocal) return;\r\n    const joystickContainer = document.createElement(\"div\");\r\n    joystickContainer.style.position = \"absolute\";\r\n    joystickContainer.style.bottom = \"0px\";\r\n    joystickContainer.style.left = \"0px\";\r\n    joystickContainer.style.width = \"50%\";\r\n    joystickContainer.style.height = \"70%\";\r\n    //user select none.\r\n    joystickContainer.style.webkitUserSelect = \"none\";\r\n    joystickContainer.style.mozUserSelect = \"none\";\r\n    joystickContainer.style.msUserSelect = \"none\";\r\n    joystickContainer.style.userSelect = \"none\";\r\n    document.body.appendChild(joystickContainer);\r\n  \r\n    this.joystick = nipplejs.create({\r\n      zone: joystickContainer,\r\n      mode: 'dynamic',\r\n      position: { left: '75%', top: '50%' },\r\n      size: 100,\r\n      color: 'white',\r\n    });\r\n  \r\n    this.joystick.on('move', (event, data) => {\r\n      const angle = data.angle.degree;\r\n  \r\n      this.actions.acceleration = false;\r\n      this.actions.braking = false;\r\n      this.actions.right = false;\r\n      this.actions.left = false;\r\n  \r\n      if (angle >= 10 && angle < 70) {\r\n        this.actions.acceleration |= true;\r\n        this.actions.right |= true;\r\n      } else if (angle >= 110 && angle < 170) {\r\n        this.actions.acceleration |= true;\r\n        this.actions.left |= true;\r\n      } else if (angle >= 70 && angle < 110) {\r\n        this.actions.acceleration |= true;\r\n      }\r\n  \r\n      if (angle >= 235 && angle < 255) {\r\n        this.actions.braking |= true;\r\n        this.actions.left |= true;\r\n      } else if (angle >= 285 && angle < 310) {\r\n        this.actions.braking |= true;\r\n        this.actions.right |= true;\r\n      } else if (angle >= 255 && angle < 285) {\r\n        this.actions.braking |= true;\r\n      }\r\n  \r\n      if (angle >= 0 && angle < 10 || angle >= 310 && angle < 360) {\r\n        this.actions.right |= true;\r\n      }\r\n  \r\n      if (angle >= 170 && angle < 235) {\r\n        this.actions.left |= true;\r\n      }\r\n    });\r\n    \r\n    this.joystick.on('end', () => {\r\n      this.actions.acceleration = false;\r\n      this.actions.braking = false;\r\n      this.actions.right = false;\r\n      this.actions.left = false;\r\n      this.actions.up = false;\r\n      this.actions.down = false;\r\n    });\r\n  }\r\n  \r\n\r\n  createButtons() {\r\n    if(!this.isLocal) return;\r\n    // Create braking button\r\n    const brakingButton = BABYLON.GUI.Button.CreateSimpleButton(\"brakingButton\", \"Brake\");\r\n    brakingButton.width = \"250px\";\r\n    brakingButton.height = \"125px\";\r\n    brakingButton.color = \"white\";\r\n    brakingButton.background = \"black\";\r\n    brakingButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    brakingButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    brakingButton.paddingRight = \"10px\";\r\n    brakingButton.paddingBottom = \"10px\";\r\n    brakingButton.top = \"-50px\";\r\n    brakingButton.textBlock.fontSize = 40;\r\n    this.advancedTexture.addControl(brakingButton);\r\n\r\n    brakingButton.onPointerDownObservable.add(() => {\r\n      this.actions.drift = true;\r\n    });\r\n\r\n    brakingButton.onPointerUpObservable.add(() => {\r\n      this.actions.drift = false;\r\n    });\r\n\r\n    // Create boost button\r\n    const boostButton = BABYLON.GUI.Button.CreateSimpleButton(\"boostButton\", \"Boost\");\r\n    boostButton.width = \"250px\";\r\n    boostButton.height = \"125px\";\r\n    boostButton.color = \"white\";\r\n    boostButton.background = \"black\";\r\n    boostButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    boostButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    boostButton.paddingRight = \"10px\";\r\n    boostButton.paddingBottom = \"10px\";\r\n    boostButton.top = \"-190px\"; // Set the initial position of the boost button\r\n    boostButton.textBlock.fontSize = 40;\r\n    this.advancedTexture.addControl(boostButton);\r\n\r\n    boostButton.onPointerDownObservable.add(() => {\r\n      this.actions.boost = true;\r\n    });\r\n\r\n    boostButton.onPointerUpObservable.add(() => {\r\n      this.actions.boost = false;\r\n    });\r\n\r\n    const specialButton = BABYLON.GUI.Button.CreateSimpleButton(\"specialButton\", \"Special\");\r\n    specialButton.width = \"250px\";\r\n    specialButton.height = \"125px\";\r\n    specialButton.color = \"white\";\r\n    specialButton.background = \"black\";\r\n    specialButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    specialButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    specialButton.paddingRight = \"10px\";\r\n    specialButton.paddingBottom = \"10px\";\r\n    specialButton.top = \"-330px\"; // Set the initial position of the boost button\r\n    specialButton.textBlock.fontSize = 40;\r\n    this.advancedTexture.addControl(specialButton);\r\n\r\n    specialButton.onPointerDownObservable.add(() => {\r\n      const currentTime = Date.now();\r\n      if (currentTime - this.lastSpecialTime >= 5000) {\r\n        this.actions.special = true;\r\n        this.lastSpecialTime = currentTime;\r\n    \r\n        // Reset the height of the specialFill rectangle\r\n        specialFill.height = \"125px\";\r\n        this.advancedTexture.addControl(specialFill);\r\n      }\r\n    });\r\n\r\n    specialButton.onPointerUpObservable.add(() => {\r\n      this.actions.special = false;\r\n    });\r\n\r\n    const special2Button = BABYLON.GUI.Button.CreateSimpleButton(\"special2Button\", \"Special2\");\r\n    special2Button.width = \"250px\";\r\n    special2Button.height = \"125px\";\r\n    special2Button.color = \"white\";\r\n    special2Button.background = \"black\";\r\n    special2Button.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    special2Button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    special2Button.paddingRight = \"10px\";\r\n    special2Button.paddingBottom = \"10px\";\r\n    special2Button.top = \"-470px\"; // Set the initial position of the boost button\r\n    special2Button.textBlock.fontSize = 40;\r\n    this.advancedTexture.addControl(special2Button);\r\n\r\n    special2Button.onPointerDownObservable.add(() => {\r\n      const currentTime = Date.now();\r\n      if (currentTime - this.lastSpecial2Time >= 5000) {\r\n        this.actions.special2 = true;\r\n        this.lastSpecial2Time = currentTime;\r\n    \r\n        // Reset the height of the special2Fill rectangle\r\n        special2Fill.height = \"125px\";\r\n        this.advancedTexture.addControl(special2Fill);\r\n      }\r\n    });\r\n\r\n    special2Button.onPointerUpObservable.add(() => {\r\n      this.actions.special2 = false;\r\n    });\r\n\r\n    const special3Button = BABYLON.GUI.Button.CreateSimpleButton(\"special3Button\", \"Special3\");\r\n    special3Button.width = \"250px\";\r\n    special3Button.height = \"125px\";\r\n    special3Button.color = \"white\";\r\n    special3Button.background = \"black\";\r\n    special3Button.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    special3Button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    special3Button.paddingRight = \"10px\";\r\n    special3Button.paddingBottom = \"10px\";\r\n    special3Button.top = \"-610px\"; // Set the initial position of the boost button\r\n    special3Button.textBlock.fontSize = 40;\r\n    this.advancedTexture.addControl(special3Button);\r\n\r\n    special3Button.onPointerDownObservable.add(() => {\r\n      const currentTime = Date.now();\r\n      if (currentTime - this.lastSpecial3Time >= 5000) {\r\n        this.actions.special3 = true;\r\n        this.lastSpecial3Time = currentTime;\r\n    \r\n        // Reset the height of the special3Fill rectangle\r\n        special3Fill.height = \"125px\";\r\n        this.advancedTexture.addControl(special3Fill);\r\n      }\r\n    });\r\n\r\n    special3Button.onPointerUpObservable.add(() => {\r\n      this.actions.special3 = false;\r\n    });\r\n\r\n    // Special Button filling effect\r\n    const specialFill = new BABYLON.GUI.Rectangle();\r\n    specialFill.width = \"250px\";\r\n    specialFill.height = \"0px\";\r\n    specialFill.color = \"white\";\r\n    specialFill.background = \"green\";\r\n    specialFill.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    specialFill.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    specialFill.paddingRight = \"10px\";\r\n    specialFill.paddingBottom = \"10px\";\r\n    specialFill.top = \"-330px\"; // Set the initial position of the special fill\r\n    this.advancedTexture.addControl(specialFill);\r\n\r\n    // Special2 Button filling effect\r\n    const special2Fill = new BABYLON.GUI.Rectangle();\r\n    special2Fill.width = \"250px\";\r\n    special2Fill.height = \"0px\";\r\n    special2Fill.color = \"white\";\r\n    special2Fill.background = \"green\";\r\n    special2Fill.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    special2Fill.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    special2Fill.paddingRight = \"10px\";\r\n    special2Fill.paddingBottom = \"10px\";\r\n    special2Fill.top = \"-470px\"; // Set the initial position of the special2 fill\r\n    this.advancedTexture.addControl(special2Fill);\r\n\r\n    // Special3 Button filling effect\r\n    const special3Fill = new BABYLON.GUI.Rectangle();\r\n    special3Fill.width = \"250px\";\r\n    special3Fill.height = \"0px\";\r\n    special3Fill.color = \"white\";\r\n    special3Fill.background = \"green\";\r\n    special3Fill.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    special3Fill.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    special3Fill.paddingRight = \"10px\";\r\n    special3Fill.paddingBottom = \"10px\";\r\n    special3Fill.top = \"-610px\"; // Set the initial position of the special3 fill\r\n    this.advancedTexture.addControl(special3Fill);\r\n\r\n    // Update the height of the filling rectangles and button states\r\n    const updateFillingHeight = () => {\r\n      const currentTime = Date.now();\r\n\r\n      const specialElapsedTime = (currentTime - this.lastSpecialTime) / 5000;\r\n      const specialHeight = Math.max(0, 125 - specialElapsedTime * 125);\r\n      specialFill.height = specialHeight + \"px\";\r\n      specialButton.background = specialElapsedTime >= 1 ? \"black\" : \"gray\";\r\n      specialButton.isHitTestVisible = specialElapsedTime >= 1;\r\n\r\n      const special2ElapsedTime = (currentTime - this.lastSpecial2Time) / 5000;\r\n      const special2Height = Math.max(0, 125 - special2ElapsedTime * 125);\r\n      special2Fill.height = special2Height + \"px\";\r\n      special2Button.background = special2ElapsedTime >= 1 ? \"black\" : \"gray\";\r\n      special2Button.isHitTestVisible = special2ElapsedTime >= 1;\r\n\r\n      const special3ElapsedTime = (currentTime - this.lastSpecial3Time) / 5000;\r\n      const special3Height = Math.max(0, 125 - special3ElapsedTime * 125);\r\n      special3Fill.height = special3Height + \"px\";\r\n      special3Button.background = special3ElapsedTime >= 1 ? \"black\" : \"gray\";\r\n      special3Button.isHitTestVisible = special3ElapsedTime >= 1;\r\n\r\n      // Schedule the next update\r\n      setTimeout(updateFillingHeight, 50);\r\n    };\r\n\r\n    // Start the update loop\r\n    updateFillingHeight();\r\n  }\r\n\r\n  respawn() {\r\n    var transform = new Ammo.btTransform();\r\n    transform.setIdentity();\r\n    transform.setOrigin(new Ammo.btVector3(0, 0, 0));\r\n    transform.setRotation(new Ammo.btQuaternion(0, 0, 0, 1));\r\n    this.body.setCenterOfMassTransform(transform);\r\n    this.body.setLinearVelocity(new Ammo.btVector3(0, 0, 0));\r\n    this.body.setAngularVelocity(new Ammo.btVector3(0, 0, 0));\r\n    this.body.activate();\r\n  }\r\n\r\n  createBoostParticles() {\r\n    const particleSystem = new BABYLON.ParticleSystem(\"particles\", 2000, this.scene);\r\n    particleSystem.particleTexture = new BABYLON.Texture(\"../textures/boost.png\", this.scene);\r\n    particleSystem.emitter = this.mesh;\r\n    particleSystem.minEmitBox = new BABYLON.Vector3(-0.5, 0, 2);\r\n    particleSystem.maxEmitBox = new BABYLON.Vector3(0.5, 0, 2);\r\n\r\n    particleSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0.5);\r\n    particleSystem.minSize = 0.1;\r\n    particleSystem.maxSize = 0.3;\r\n    particleSystem.minLifeTime = 0.1;\r\n    particleSystem.maxLifeTime = 0.11;\r\n    particleSystem.emitRate = 2000;\r\n    particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;\r\n    particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);\r\n    particleSystem.direction1 = new BABYLON.Vector3(0, 0, 2);\r\n    particleSystem.direction2 = new BABYLON.Vector3(0, 0, 2);\r\n    particleSystem.minEmitPower = 1;\r\n    particleSystem.maxEmitPower = 3;\r\n    particleSystem.updateSpeed = 0.005;\r\n  \r\n    return particleSystem;\r\n  }\r\n\r\n  createVehicle(pos, quat) {\r\n    const addWheel = (isFront, pos, radius, width, index) => {\r\n\r\n      var wheelInfo = vehicle.addWheel(\r\n        pos,\r\n        wheelDirectionCS0,\r\n        wheelAxleCS,\r\n        suspensionRestLength,\r\n        radius,\r\n        tuning,\r\n        isFront);\r\n        if (!isFront) {\r\n          wheelInfo.set_m_frictionSlip(driftFriction);\r\n        }\r\n      wheelInfo.set_m_suspensionStiffness(suspensionStiffness);\r\n      wheelInfo.set_m_wheelsDampingRelaxation(suspensionDamping);\r\n      wheelInfo.set_m_wheelsDampingCompression(suspensionCompression);\r\n      wheelInfo.set_m_maxSuspensionForce(600000);\r\n      wheelInfo.set_m_frictionSlip(20);\r\n      wheelInfo.set_m_rollInfluence(rollInfluence);\r\n\r\n      var wheelMaterial = new BABYLON.StandardMaterial(\"wheelMaterial\");\r\n      wheelMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);\r\n    \r\n      this.wheelMeshes[index] = createWheelMesh(radius, width);\r\n      if (isFront) {\r\n        var wheelMaterial = new BABYLON.StandardMaterial(\"wheelMaterial\");\r\n        wheelMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);\r\n        this.wheelMeshes[index].material = wheelMaterial;\r\n      }\r\n    }\r\n\r\n    function createWheelMesh(radius, width) {\r\n      //var mesh = new BABYLON.MeshBuilder.CreateBox(\"wheel\", {width:.82, height:.82, depth:.82});\r\n      var mesh = new BABYLON.MeshBuilder.CreateCylinder(\"Wheel\", { diameter: 1.5, height: 0.8, tessellation: 12 });\r\n      mesh.rotationQuaternion = new BABYLON.Quaternion();\r\n      return mesh;\r\n    }\r\n\r\n    function createChassisMesh(w, l, h, color) {\r\n      var mesh = new BABYLON.MeshBuilder.CreateBox(\"box\", { width: w, depth: h, height: l });\r\n      mesh.rotationQuaternion = new BABYLON.Quaternion();\r\n    \r\n      var chassisMaterial = new BABYLON.StandardMaterial(\"chassisMaterial\");\r\n      chassisMaterial.diffuseColor = color;\r\n      mesh.material = chassisMaterial;\r\n    \r\n      return mesh;\r\n    }\r\n\r\n    var vehicle, chassisMesh;\r\n    \r\n\r\n    var vehicleReady = false;\r\n\r\n    var chassisWidth = 1.8;\r\n    var chassisHeight = .6;\r\n    var chassisLength = 4;\r\n    var massVehicle = 400;//200\r\n\r\n    var wheelAxisPositionBack = -2;\r\n    var wheelRadiusBack = .8;\r\n    var wheelWidthBack = .6;\r\n    var wheelHalfTrackBack = 1.5;\r\n    var wheelAxisHeightBack = 0.4;\r\n\r\n    var wheelAxisFrontPosition = 2.0;\r\n    var wheelHalfTrackFront = 1.5;\r\n    var wheelAxisHeightFront = 0.4;\r\n    var wheelRadiusFront = .8;\r\n    var wheelWidthFront = .6;\r\n\r\n    var friction = 5;\r\n    var suspensionStiffness = 20;\r\n    var suspensionDamping = 1;\r\n    var suspensionCompression = 2;\r\n    var suspensionRestLength = 0.6;\r\n    var rollInfluence = -0.2;\r\n\r\n    var steeringIncrement = .01;\r\n    var steeringClamp = 0.4;\r\n    var maxEngineForce = 3000;\r\n    var maxBreakingForce = 20;\r\n    var incEngine = 10.0;\r\n    var driftBreakingForce = 7;\r\n\r\n    var FRONT_LEFT = 0;\r\n    var FRONT_RIGHT = 1;\r\n    var BACK_LEFT = 2;\r\n    var BACK_RIGHT = 3;\r\n\r\n    var driftFriction = 40;\r\n\r\n    var wheelDirectionCS0;\r\n    var wheelAxleCS;\r\n\r\n    var physicsWorld = this.scene.getPhysicsEngine().getPhysicsPlugin().world;\r\n\r\n    var wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0);\r\n    var wheelAxleCS = new Ammo.btVector3(-1, 0, 0);\r\n\r\n    var localPlayerColor = new BABYLON.Color3(1, 1, 0); // Yellow\r\n    var otherPlayerColor = new BABYLON.Color3(1, 0, 0); // Red\r\n\r\n    var geometry = new Ammo.btBoxShape(new Ammo.btVector3(chassisWidth * 1, chassisHeight * 1, chassisLength * 0.75));\r\n    var transform = new Ammo.btTransform();\r\n    transform.setIdentity();\r\n    transform.setOrigin(new Ammo.btVector3(this.position.x, this.position.y, this.position.x));\r\n    transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));\r\n    var motionState = new Ammo.btDefaultMotionState(transform);\r\n    var localInertia = new Ammo.btVector3(0, 0, 0);\r\n    geometry.calculateLocalInertia(massVehicle, localInertia);\r\n\r\n    chassisMesh = createChassisMesh(chassisWidth * 1.5, chassisHeight * 1.5, chassisLength * 1.5, this.isLocal ? localPlayerColor : otherPlayerColor);\r\n\r\n    var massOffset = new Ammo.btVector3(0, 0.4, 0);\r\n    var transform2 = new Ammo.btTransform();\r\n    transform2.setIdentity();\r\n    transform2.setOrigin(massOffset);\r\n    var compound = new Ammo.btCompoundShape();\r\n    compound.addChildShape(transform2, geometry);\r\n    compound.position = this.position;\r\n    var body = new Ammo.btRigidBody(new Ammo.btRigidBodyConstructionInfo(massVehicle, motionState, compound, localInertia));\r\n    body.setActivationState(4);\r\n\r\n    this.body = body;\r\n\r\n    physicsWorld.addRigidBody(body);\r\n\r\n    var engineForce = 0;\r\n    var vehicleSteering = 0;\r\n    var breakingForce = 0;\r\n    var tuning = new Ammo.btVehicleTuning();\r\n    var rayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld);\r\n    vehicle = new Ammo.btRaycastVehicle(tuning, body, rayCaster);\r\n    vehicle.setCoordinateSystem(0, 1, 2);\r\n    physicsWorld.addAction(vehicle);\r\n\r\n    var trans = vehicle.getChassisWorldTransform();\r\n    trans.setOrigin(new Ammo.btVector3(this.position.x, this.position.y, this.position.z));\r\n    //vehicle.setChassisWorldTransform(trans);\r\n\r\n    addWheel(true, new Ammo.btVector3(wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_LEFT);\r\n    addWheel(true, new Ammo.btVector3(-wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_RIGHT);\r\n    addWheel(false, new Ammo.btVector3(-wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_LEFT);\r\n    addWheel(false, new Ammo.btVector3(wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_RIGHT);\r\n\r\n    vehicleReady = true;\r\n\r\n    this.scene.registerBeforeRender(() => {\r\n      // var dt = this.engine.getDeltaTime().toFixed() / 1000;,\r\n\r\n      if (vehicleReady ) {\r\n\r\n        var speed = vehicle.getCurrentSpeedKmHour();\r\n        var maxSteerVal = 0.2;\r\n        breakingForce = 0;\r\n        engineForce = 0;\r\n\r\n        if (this.actions.acceleration) {\r\n          if (speed < -1) {\r\n            breakingForce = maxBreakingForce;\r\n          } else {\r\n            engineForce = maxEngineForce;\r\n          }\r\n\r\n        } else if (this.actions.braking) {\r\n          if (speed > 1) {\r\n            breakingForce = maxBreakingForce;\r\n          } else {\r\n            engineForce = -maxEngineForce;\r\n          }\r\n        }\r\n\r\n        if (this.actions.right) {\r\n          if (vehicleSteering < steeringClamp) {\r\n            vehicleSteering += steeringIncrement;\r\n          }\r\n\r\n        } else if (this.actions.left) {\r\n          if (vehicleSteering > -steeringClamp) {\r\n            vehicleSteering -= steeringIncrement;\r\n          }\r\n\r\n        } else {\r\n          vehicleSteering = 0;\r\n        }\r\n\r\n        if (this.actions.drift) {\r\n          driftFriction = 5;\r\n          breakingForce += driftBreakingForce * 6;\r\n        } else {\r\n          driftFriction = 40;\r\n        }\r\n\r\n        if (this.actions.boost) {\r\n          engineForce = maxEngineForce * 1.6;\r\n          if (!this.boostParticles.isStarted()) {\r\n            this.boostParticles.start();\r\n          }\r\n        } else {\r\n          if (this.boostParticles.isStarted()) {\r\n            this.boostParticles.stop();\r\n          }\r\n        }\r\n\r\n        if(this.actions.special && !this.specialActive) {\r\n          // Mark special as active\r\n          this.specialActive = true;\r\n          this.engineForceMultiplier = 0;\r\n\r\n          // Apply a large braking force to all wheels\r\n          vehicle.setBrake(10000, FRONT_LEFT);\r\n          vehicle.setBrake(10000, FRONT_RIGHT);\r\n          vehicle.setBrake(10000, BACK_LEFT);\r\n          vehicle.setBrake(10000, BACK_RIGHT);\r\n        \r\n          // Set the car's linear and angular velocity to zero\r\n          const linearVelocity = this.body.getLinearVelocity();\r\n          linearVelocity.setValue(0, 0, 0);\r\n          this.body.setLinearVelocity(linearVelocity);\r\n        \r\n          const angularVelocity = this.body.getAngularVelocity();\r\n          angularVelocity.setValue(0, 0, 0);\r\n          this.body.setAngularVelocity(angularVelocity);\r\n        \r\n          // Set a timer to release the brakes and restore the car's control after 2 seconds\r\n          setTimeout(() => {\r\n            vehicle.setBrake(0, FRONT_LEFT);\r\n            vehicle.setBrake(0, FRONT_RIGHT);\r\n            vehicle.setBrake(0, BACK_LEFT);\r\n            vehicle.setBrake(0, BACK_RIGHT);\r\n        \r\n            // Mark special as inactive\r\n            this.specialActive = false;\r\n            this.engineForceMultiplier = 1;\r\n          }, 2000);\r\n        }        \r\n\r\n        if(this.actions.special2 && !this.special2Active) {\r\n          // Mark special2 as active\r\n          this.special2Active = true;\r\n        \r\n          // Increase the car's mass by a factor of 10\r\n          const massFactor = 10;\r\n          const originalMass = massVehicle;\r\n          const increasedMass = originalMass * massFactor;\r\n          this.body.setMassProps(increasedMass, localInertia);\r\n        \r\n          // Set the car's linear and angular velocity to zero\r\n          const linearVelocity = this.body.getLinearVelocity();\r\n          linearVelocity.setValue(0, 0, 0);\r\n          this.body.setLinearVelocity(linearVelocity);\r\n        \r\n          const angularVelocity = this.body.getAngularVelocity();\r\n          angularVelocity.setValue(0, 0, 0);\r\n          this.body.setAngularVelocity(angularVelocity);\r\n        \r\n          // Set a timer to reset the mass after 2 seconds\r\n          setTimeout(() => {\r\n            // Reset the car's mass to the original value\r\n            this.body.setMassProps(originalMass, localInertia);\r\n          \r\n            // Release the brakes after a short delay\r\n            setTimeout(() => {\r\n              vehicle.setBrake(0, FRONT_LEFT);\r\n              vehicle.setBrake(0, FRONT_RIGHT);\r\n              vehicle.setBrake(0, BACK_LEFT);\r\n              vehicle.setBrake(0, BACK_RIGHT);\r\n          \r\n              // Mark special2 as inactive\r\n              this.special2Active = false;\r\n            }, 200);\r\n          }, 2000);\r\n          \r\n        }\r\n        \r\n        if (this.actions.special3 && !this.special3Active) {\r\n          // Mark special3 as active\r\n          this.special3Active = true;\r\n      \r\n          // Calculate the current speed and movement direction\r\n          const speed = vehicle.getCurrentSpeedKmHour() / 3.6;\r\n          const movementDirection = vehicle.getForwardVector();\r\n      \r\n          // Calculate the extra force for the quick dash\r\n          const dashForce = 50000;\r\n      \r\n          // Apply the dash force to the vehicle\r\n          const impulse = new Ammo.btVector3(movementDirection.x() * dashForce, 0, movementDirection.z() * dashForce);\r\n          this.body.applyCentralImpulse(impulse);\r\n      \r\n          // Set a timer to mark special3 as inactive after a short delay\r\n          setTimeout(() => {\r\n            this.special3Active = false;\r\n            const stopImpulse = new Ammo.btVector3(0, 0, 0);\r\n            this.body.setLinearVelocity(stopImpulse);\r\n          }, 200);\r\n\r\n        }\r\n        \r\n        vehicle.getWheelInfo(BACK_LEFT).set_m_frictionSlip(driftFriction / 1.1);\r\n        vehicle.getWheelInfo(BACK_RIGHT).set_m_frictionSlip(driftFriction / 1.1);\r\n        vehicle.getWheelInfo(FRONT_LEFT).set_m_frictionSlip(driftFriction);\r\n        vehicle.getWheelInfo(FRONT_RIGHT).set_m_frictionSlip(driftFriction);\r\n        \r\n        vehicle.applyEngineForce(engineForce * this.engineForceMultiplier, FRONT_LEFT);\r\n        vehicle.applyEngineForce(engineForce * this.engineForceMultiplier, FRONT_RIGHT);\r\n\r\n        vehicle.setBrake(breakingForce / 2, FRONT_LEFT);\r\n        vehicle.setBrake(breakingForce / 2, FRONT_RIGHT);\r\n        vehicle.setBrake(breakingForce, BACK_LEFT);\r\n        vehicle.setBrake(breakingForce, BACK_RIGHT);\r\n\r\n        vehicle.setSteeringValue(vehicleSteering, FRONT_LEFT);\r\n        vehicle.setSteeringValue(vehicleSteering, FRONT_RIGHT);\r\n\r\n        var tm, p, q, i;\r\n        var n = vehicle.getNumWheels();\r\n        for (i = 0; i < n; i++) {\r\n          vehicle.updateWheelTransform(i, true);\r\n          tm = vehicle.getWheelTransformWS(i);\r\n          p = tm.getOrigin();\r\n          q = tm.getRotation();\r\n          this.wheelMeshes[i].position.set(p.x(), p.y(), p.z());\r\n          this.wheelMeshes[i].rotationQuaternion.set(q.x(), q.y(), q.z(), q.w());\r\n          this.wheelMeshes[i].rotate(BABYLON.Axis.Z, Math.PI / 2);\r\n        }\r\n\r\n        tm = vehicle.getChassisWorldTransform();\r\n        p = tm.getOrigin();\r\n        q = tm.getRotation();\r\n        chassisMesh.position.set(p.x(), p.y(), p.z());\r\n        chassisMesh.rotationQuaternion.set(q.x(), q.y(), q.z(), q.w());\r\n        \r\n        //chassisMesh.rotate(BABYLON.Axis.X, Math.PI);\r\n      }\r\n      if (chassisMesh.position.y < -5) {\r\n        this.respawn();\r\n      }\r\n    });\r\n\r\n    \r\n    return chassisMesh  ;\r\n  }\r\n\r\n  setupControls() {\r\n\r\n  }  \r\n\r\n  moveForward() {\r\n    this.mesh.position.z -= this.speed;\r\n  }\r\n\r\n  moveBackward() {\r\n    this.mesh.position.z += this.speed;\r\n  }\r\n\r\n  moveLeft() {\r\n    this.mesh.position.x -= this.speed;\r\n  }\r\n\r\n  moveRight() {\r\n    this.mesh.position.x += this.speed;\r\n  }\r\n\r\n  updatePosition(position) {\r\n    this.mesh.position = position;\r\n  }\r\n\r\n  destroy() {\r\n    if (this.body) {\r\n      const physicsEngine = this.scene.getPhysicsEngine();\r\n      const physicsWorld = physicsEngine.getPhysicsPlugin().world;\r\n      physicsWorld.removeRigidBody(this.body);\r\n      this.body = null;\r\n    }\r\n    if (this.vehicle) {\r\n      this.scene.getPhysicsEngine().removeAction(this.vehicle);\r\n      this.vehicle = null;\r\n    }\r\n    if (this.mesh) {\r\n      this.wheelMeshes.forEach((wheelMesh) => { wheelMesh.dispose() });\r\n      this.mesh.dispose();\r\n      this.mesh = null;\r\n      console.log(`Player ${this.id} destroyed`);\r\n    } else {\r\n      console.warn(`Attempted to destroy player ${this.id} but mesh is not initialized`);\r\n    }\r\n  }\r\n}\n\n//# sourceURL=webpack://my-app/./src/scripts/classes/Player.js?");

/***/ }),

/***/ "./src/scripts/scenes/game2.js":
/*!*************************************!*\
  !*** ./src/scripts/scenes/game2.js ***!
  \*************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (67:0)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n|   // Add the local player\\n> <<<<<<< HEAD\\n| const randomX = Math.random() * (groundRadius * 2) - groundRadius;\\n|   const randomZ = Math.random() * (groundRadius * 2) - groundRadius;\");\n\n//# sourceURL=webpack://my-app/./src/scripts/scenes/game2.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	__webpack_modules__["./src/scripts/classes/Player.js"](0, {}, __webpack_require__);
/******/ 	__webpack_modules__["./src/scripts/classes/PhotonManager.js"](0, {}, __webpack_require__);
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/scripts/scenes/game2.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;