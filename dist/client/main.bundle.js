/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/scripts/classes/ButtonsNDJoystick/Buttons.js":
/*!**********************************************************!*\
  !*** ./src/scripts/classes/ButtonsNDJoystick/Buttons.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Gamebuttons\": () => (/* binding */ Gamebuttons)\n/* harmony export */ });\nclass Gamebuttons {\n    createButtons() {\n    if(!this.isLocal) return;\n    // Create braking button\n    const brakingButton = BABYLON.GUI.Button.CreateSimpleButton(\"brakingButton\", \"Brake\");\n    brakingButton.width = \"250px\";\n    brakingButton.height = \"125px\";\n    brakingButton.color = \"white\";\n    brakingButton.background = \"black\";\n    brakingButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n    brakingButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n    brakingButton.paddingRight = \"10px\";\n    brakingButton.paddingBottom = \"10px\";\n    brakingButton.top = \"-50px\";\n    brakingButton.textBlock.fontSize = 40;\n    this.advancedTexture.addControl(brakingButton);\n\n    brakingButton.onPointerDownObservable.add(() => {\n      this.actions.drift = true;\n    });\n\n    brakingButton.onPointerUpObservable.add(() => {\n      this.actions.drift = false;\n    });\n\n    // Create boost button\n    const boostButton = BABYLON.GUI.Button.CreateSimpleButton(\"boostButton\", \"Boost\");\n    boostButton.width = \"250px\";\n    boostButton.height = \"125px\";\n    boostButton.color = \"white\";\n    boostButton.background = \"black\";\n    boostButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n    boostButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n    boostButton.paddingRight = \"10px\";\n    boostButton.paddingBottom = \"10px\";\n    boostButton.top = \"-190px\"; // Set the initial position of the boost button\n    boostButton.textBlock.fontSize = 40;\n    this.advancedTexture.addControl(boostButton);\n\n    boostButton.onPointerDownObservable.add(() => {\n      this.actions.boost = true;\n    });\n\n    boostButton.onPointerUpObservable.add(() => {\n      this.actions.boost = false;\n    });\n\n    const specialButton = BABYLON.GUI.Button.CreateSimpleButton(\"specialButton\", \"Special\");\n    specialButton.width = \"250px\";\n    specialButton.height = \"125px\";\n    specialButton.color = \"white\";\n    specialButton.background = \"black\";\n    specialButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n    specialButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n    specialButton.paddingRight = \"10px\";\n    specialButton.paddingBottom = \"10px\";\n    specialButton.top = \"-330px\"; // Set the initial position of the boost button\n    specialButton.textBlock.fontSize = 40;\n    this.advancedTexture.addControl(specialButton);\n\n    specialButton.onPointerDownObservable.add(() => {\n      const currentTime = Date.now();\n      if (currentTime - this.lastSpecialTime >= 5000) {\n        this.actions.special = true;\n        this.lastSpecialTime = currentTime;\n    \n        // Reset the height of the specialFill rectangle\n        specialFill.height = \"125px\";\n        this.advancedTexture.addControl(specialFill);\n      }\n    });\n\n    specialButton.onPointerUpObservable.add(() => {\n      this.actions.special = false;\n    });\n\n    const special2Button = BABYLON.GUI.Button.CreateSimpleButton(\"special2Button\", \"Special2\");\n    special2Button.width = \"250px\";\n    special2Button.height = \"125px\";\n    special2Button.color = \"white\";\n    special2Button.background = \"black\";\n    special2Button.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n    special2Button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n    special2Button.paddingRight = \"10px\";\n    special2Button.paddingBottom = \"10px\";\n    special2Button.top = \"-470px\"; // Set the initial position of the boost button\n    special2Button.textBlock.fontSize = 40;\n    this.advancedTexture.addControl(special2Button);\n\n    special2Button.onPointerDownObservable.add(() => {\n      const currentTime = Date.now();\n      if (currentTime - this.lastSpecial2Time >= 5000) {\n        this.actions.special2 = true;\n        this.lastSpecial2Time = currentTime;\n    \n        // Reset the height of the special2Fill rectangle\n        special2Fill.height = \"125px\";\n        this.advancedTexture.addControl(special2Fill);\n      }\n    });\n\n    special2Button.onPointerUpObservable.add(() => {\n      this.actions.special2 = false;\n    });\n\n    const special3Button = BABYLON.GUI.Button.CreateSimpleButton(\"special3Button\", \"Special3\");\n    special3Button.width = \"250px\";\n    special3Button.height = \"125px\";\n    special3Button.color = \"white\";\n    special3Button.background = \"black\";\n    special3Button.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n    special3Button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n    special3Button.paddingRight = \"10px\";\n    special3Button.paddingBottom = \"10px\";\n    special3Button.top = \"-610px\"; // Set the initial position of the boost button\n    special3Button.textBlock.fontSize = 40;\n    this.advancedTexture.addControl(special3Button);\n\n    special3Button.onPointerDownObservable.add(() => {\n      const currentTime = Date.now();\n      if (currentTime - this.lastSpecial3Time >= 5000) {\n        this.actions.special3 = true;\n        this.lastSpecial3Time = currentTime;\n    \n        // Reset the height of the special3Fill rectangle\n        special3Fill.height = \"125px\";\n        this.advancedTexture.addControl(special3Fill);\n      }\n    });\n\n    special3Button.onPointerUpObservable.add(() => {\n      this.actions.special3 = false;\n    });\n\n    // Special Button filling effect\n    const specialFill = new BABYLON.GUI.Rectangle();\n    specialFill.width = \"250px\";\n    specialFill.height = \"0px\";\n    specialFill.color = \"white\";\n    specialFill.background = \"green\";\n    specialFill.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n    specialFill.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n    specialFill.paddingRight = \"10px\";\n    specialFill.paddingBottom = \"10px\";\n    specialFill.top = \"-330px\"; // Set the initial position of the special fill\n    this.advancedTexture.addControl(specialFill);\n\n    // Special2 Button filling effect\n    const special2Fill = new BABYLON.GUI.Rectangle();\n    special2Fill.width = \"250px\";\n    special2Fill.height = \"0px\";\n    special2Fill.color = \"white\";\n    special2Fill.background = \"green\";\n    special2Fill.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n    special2Fill.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n    special2Fill.paddingRight = \"10px\";\n    special2Fill.paddingBottom = \"10px\";\n    special2Fill.top = \"-470px\"; // Set the initial position of the special2 fill\n    this.advancedTexture.addControl(special2Fill);\n\n    // Special3 Button filling effect\n    const special3Fill = new BABYLON.GUI.Rectangle();\n    special3Fill.width = \"250px\";\n    special3Fill.height = \"0px\";\n    special3Fill.color = \"white\";\n    special3Fill.background = \"green\";\n    special3Fill.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n    special3Fill.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n    special3Fill.paddingRight = \"10px\";\n    special3Fill.paddingBottom = \"10px\";\n    special3Fill.top = \"-610px\"; // Set the initial position of the special3 fill\n    this.advancedTexture.addControl(special3Fill);\n\n    // Update the height of the filling rectangles and button states\n    const updateFillingHeight = () => {\n      const currentTime = Date.now();\n\n      const specialElapsedTime = (currentTime - this.lastSpecialTime) / 5000;\n      const specialHeight = Math.max(0, 125 - specialElapsedTime * 125);\n      specialFill.height = specialHeight + \"px\";\n      specialButton.background = specialElapsedTime >= 1 ? \"black\" : \"gray\";\n      specialButton.isHitTestVisible = specialElapsedTime >= 1;\n\n      const special2ElapsedTime = (currentTime - this.lastSpecial2Time) / 5000;\n      const special2Height = Math.max(0, 125 - special2ElapsedTime * 125);\n      special2Fill.height = special2Height + \"px\";\n      special2Button.background = special2ElapsedTime >= 1 ? \"black\" : \"gray\";\n      special2Button.isHitTestVisible = special2ElapsedTime >= 1;\n\n      const special3ElapsedTime = (currentTime - this.lastSpecial3Time) / 5000;\n      const special3Height = Math.max(0, 125 - special3ElapsedTime * 125);\n      special3Fill.height = special3Height + \"px\";\n      special3Button.background = special3ElapsedTime >= 1 ? \"black\" : \"gray\";\n      special3Button.isHitTestVisible = special3ElapsedTime >= 1;\n\n      // Schedule the next update\n      setTimeout(updateFillingHeight, 50);\n    };\n\n    // Start the update loop\n    updateFillingHeight();\n    }\n}\n\n//# sourceURL=webpack://my-app/./src/scripts/classes/ButtonsNDJoystick/Buttons.js?");

/***/ }),

/***/ "./src/scripts/classes/ButtonsNDJoystick/Joystick.js":
/*!***********************************************************!*\
  !*** ./src/scripts/classes/ButtonsNDJoystick/Joystick.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Joystick\": () => (/* binding */ Joystick)\n/* harmony export */ });\nclass Joystick {\n    createJoystick() {\n        if(!this.isLocal) return;\n        const joystickContainer = document.createElement(\"div\");\n        joystickContainer.style.position = \"absolute\";\n        joystickContainer.style.bottom = \"0px\";\n        joystickContainer.style.left = \"0px\";\n        joystickContainer.style.width = \"50%\";\n        joystickContainer.style.height = \"70%\";\n        //user select none.\n        joystickContainer.style.webkitUserSelect = \"none\";\n        joystickContainer.style.mozUserSelect = \"none\";\n        joystickContainer.style.msUserSelect = \"none\";\n        joystickContainer.style.userSelect = \"none\";\n        document.body.appendChild(joystickContainer);\n      \n        this.joystick = nipplejs.create({\n          zone: joystickContainer,\n          mode: 'dynamic',\n          position: { left: '75%', top: '50%' },\n          size: 100,\n          color: 'white',\n        });\n      \n        this.joystick.on('move', (event, data) => {\n          const angle = data.angle.degree;\n      \n          this.actions.acceleration = false;\n          this.actions.braking = false;\n          this.actions.right = false;\n          this.actions.left = false;\n      \n          if (angle >= 10 && angle < 70) {\n            this.actions.acceleration |= true;\n            this.actions.right |= true;\n          } else if (angle >= 110 && angle < 170) {\n            this.actions.acceleration |= true;\n            this.actions.left |= true;\n          } else if (angle >= 70 && angle < 110) {\n            this.actions.acceleration |= true;\n          }\n      \n          if (angle >= 235 && angle < 255) {\n            this.actions.braking |= true;\n            this.actions.left |= true;\n          } else if (angle >= 285 && angle < 310) {\n            this.actions.braking |= true;\n            this.actions.right |= true;\n          } else if (angle >= 255 && angle < 285) {\n            this.actions.braking |= true;\n          }\n      \n          if (angle >= 0 && angle < 10 || angle >= 310 && angle < 360) {\n            this.actions.right |= true;\n          }\n      \n          if (angle >= 170 && angle < 235) {\n            this.actions.left |= true;\n          }\n        });\n        \n        this.joystick.on('end', () => {\n          this.actions.acceleration = false;\n          this.actions.braking = false;\n          this.actions.right = false;\n          this.actions.left = false;\n          this.actions.up = false;\n          this.actions.down = false;\n        });\n      }\n}\n\n//# sourceURL=webpack://my-app/./src/scripts/classes/ButtonsNDJoystick/Joystick.js?");

/***/ }),

/***/ "./src/scripts/classes/Particles/particles.js":
/*!****************************************************!*\
  !*** ./src/scripts/classes/Particles/particles.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Particle\": () => (/* binding */ Particle)\n/* harmony export */ });\nclass Particle {\n    createBoostParticles() {\n        const particleSystem = new BABYLON.ParticleSystem(\"particles\", 2000, this.scene);\n        particleSystem.particleTexture = new BABYLON.Texture(\"../textures/boost.png\", this.scene);\n        particleSystem.emitter = this.mesh;\n        particleSystem.minEmitBox = new BABYLON.Vector3(-0.5, 0, 2);\n        particleSystem.maxEmitBox = new BABYLON.Vector3(0.5, 0, 2);\n    \n        particleSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0.5);\n        particleSystem.minSize = 0.6;\n        particleSystem.maxSize = 0.9;\n        particleSystem.minLifeTime = 0.01;\n        particleSystem.maxLifeTime = 0.09;\n        particleSystem.emitRate = 2000;\n        particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;\n        particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);\n        particleSystem.direction1 = new BABYLON.Vector3(0, 0, 2);\n        particleSystem.direction2 = new BABYLON.Vector3(0, 0, 2);\n        particleSystem.minEmitPower = 1;\n        particleSystem.maxEmitPower = 3;\n        particleSystem.updateSpeed = 0.005;\n      \n        return particleSystem;\n    }\n    createFreezeEffectParticleSystem() {\n        const tireEffectParticleSystem = new BABYLON.ParticleSystem('tireEffect', 2000, this.scene);\n        tireEffectParticleSystem.particleTexture = new BABYLON.Texture('../textures/boost.png', this.scene);\n        tireEffectParticleSystem.emitter = this.mesh;\n        tireEffectParticleSystem.minEmitBox = new BABYLON.Vector3(-1, 0, -1);\n        tireEffectParticleSystem.maxEmitBox = new BABYLON.Vector3(1, 0, 1);\n        tireEffectParticleSystem.color1 = new BABYLON.Color4(0.7, 0.8, 1, 1);\n        tireEffectParticleSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1, 1);\n        tireEffectParticleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0);\n        tireEffectParticleSystem.minSize = 0.1;\n        tireEffectParticleSystem.maxSize = 0.5;\n        tireEffectParticleSystem.minLifeTime = 0.2;\n        tireEffectParticleSystem.maxLifeTime = 0.4;\n        tireEffectParticleSystem.emitRate = 500;\n        tireEffectParticleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;\n        tireEffectParticleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);\n        tireEffectParticleSystem.direction1 = new BABYLON.Vector3(-7, 8, 3);\n        tireEffectParticleSystem.direction2 = new BABYLON.Vector3(7, 8, -3);\n        tireEffectParticleSystem.minAngularSpeed = 0;\n        tireEffectParticleSystem.maxAngularSpeed = Math.PI;\n        tireEffectParticleSystem.minEmitPower = 1;\n        tireEffectParticleSystem.maxEmitPower = 3;\n        tireEffectParticleSystem.updateSpeed = 0.005;\n    \n        return tireEffectParticleSystem;\n      }\n      createWeightEffectParticleSystem() {\n        const weightEffect = new BABYLON.ParticleSystem('tireEffect', 2000, this.scene);\n        weightEffect.particleTexture = new BABYLON.Texture('../textures/weight.png', this.scene);\n        weightEffect.emitter = this.mesh;\n        weightEffect.minEmitBox = new BABYLON.Vector3(-1, 0, -1);\n        weightEffect.maxEmitBox = new BABYLON.Vector3(1, 0, 1);\n        weightEffect.color1 = new BABYLON.Color4(1, 1, 1, 1);\n        weightEffect.color2 = new BABYLON.Color4(1, 1, 1, 1);\n        weightEffect.colorDead = new BABYLON.Color4(0, 0, 0.2, 0);\n        weightEffect.minSize = 1.8;\n        weightEffect.maxSize = 4.2;\n        weightEffect.minLifeTime = 0.7;\n        weightEffect.maxLifeTime = 1.4;\n        weightEffect.emitRate = 17;\n        weightEffect.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;\n        weightEffect.gravity = new BABYLON.Vector3(0, 15, 0);\n        weightEffect.direction1 = new BABYLON.Vector3(-13, 12, 7);\n        weightEffect.direction2 = new BABYLON.Vector3(13, 12, -7);\n        weightEffect.minAngularSpeed = 0;\n        weightEffect.maxAngularSpeed = Math.PI;\n        weightEffect.minEmitPower = 1;\n        weightEffect.maxEmitPower = 3;\n        weightEffect.updateSpeed = 0.005;\n    \n        return weightEffect;\n      }\n      createWheelTrail() {\n        // Create particle system\n        const wheelTrail = new BABYLON.ParticleSystem(\"wheelTrail\", 400, this.scene);\n      \n        // Set particle texture and color\n        wheelTrail.particleTexture = new BABYLON.Texture(\"../textures/smoke2.png\", this.scene);\n        //dark gray color\n        wheelTrail.color1 = new BABYLON.Color4(0.1, 0.1, 0.1, 1);\n        wheelTrail.color2 = new BABYLON.Color4(0.1, 0.1, 0.1, 1);\n        wheelTrail.colorDead = new BABYLON.Color4(0, 0, 0, 0);\n      \n        // Set particle system properties\n        wheelTrail.minSize = 0.8;\n        wheelTrail.maxSize = 1.2;\n        wheelTrail.minLifeTime = 1;\n        wheelTrail.maxLifeTime = 1.6;\n        wheelTrail.emitRate = 100;\n        wheelTrail.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;\n        wheelTrail.gravity = new BABYLON.Vector3(0, -4, 0);\n      \n        // Set particle system emitter to the other back wheel\n        const emitter2 = new BABYLON.Mesh(\"emitter2\", this.scene);\n        emitter2.parent = this.mesh;\n        emitter2.position = new BABYLON.Vector3(-1.5, -1, -2.5);\n        //rotate emitter2 180 degrees\n        emitter2.rotationQuaternion = new BABYLON.Quaternion();\n        \n        wheelTrail.emitter = emitter2;\n        wheelTrail.minEmitBox = new BABYLON.Vector3(-0.1, 0, 0);\n        wheelTrail.maxEmitBox = new BABYLON.Vector3(0.1, 0, 0);\n      \n        // Start the particle system\n        wheelTrail.start();\n      \n        this.wheelTrail = wheelTrail;\n      \n        return wheelTrail;\n      }\n      createWheelSmokeTrail() {\n        // Create particle system\n        const wheelSmokeTrail = new BABYLON.ParticleSystem(\"wheelSmokeTrail\", 400, this.scene);\n      \n        // Set particle texture and color\n        wheelSmokeTrail.particleTexture = new BABYLON.Texture(\"../textures/cloud.png\", this.scene);\n        wheelSmokeTrail.color1 = new BABYLON.Color4(1, 1, 1, 1);\n        wheelSmokeTrail.color2 = new BABYLON.Color4(1, 1, 1, 1);\n        wheelSmokeTrail.colorDead = new BABYLON.Color4(0, 0, 0, 0);\n      \n        // Set particle system properties\n        wheelSmokeTrail.minSize = 1.8;\n        wheelSmokeTrail.maxSize = 4.2;\n        wheelSmokeTrail.minLifeTime = 1;\n        wheelSmokeTrail.maxLifeTime = 1.6;\n        wheelSmokeTrail.emitRate = 20;\n        wheelSmokeTrail.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;\n        wheelSmokeTrail.gravity = new BABYLON.Vector3(0, 10, 0);\n        wheelSmokeTrail.direction1 = new BABYLON.Vector3(-7, 8, 3);\n        wheelSmokeTrail.direction2 = new BABYLON.Vector3(7, 8, -3);\n      \n        // Set particle system emitter to the other back wheel\n        const emitter2 = new BABYLON.Mesh(\"emitter2\", this.scene);\n        emitter2.parent = this.mesh;\n        emitter2.position = new BABYLON.Vector3(1.5, -1, -2.5);\n        //rotate emitter2 180 degrees\n        emitter2.rotationQuaternion = new BABYLON.Quaternion();\n        \n        wheelSmokeTrail.emitter = emitter2;\n        wheelSmokeTrail.minEmitBox = new BABYLON.Vector3(-0.1, 0, 0);\n        wheelSmokeTrail.maxEmitBox = new BABYLON.Vector3(0.1, 0, 0);\n      \n        // Start the particle system\n        wheelSmokeTrail.start();\n      \n        this.wheelSmokeTrail = wheelSmokeTrail;\n      \n        return wheelSmokeTrail;\n      }\n      createWheelTrail2() {\n        // Create particle system\n        const wheelTrail2 = new BABYLON.ParticleSystem(\"wheelTrail2\", 400, this.scene);\n      \n        // Set particle texture and color\n        wheelTrail2.particleTexture = new BABYLON.Texture(\"../textures/smoke2.png\", this.scene);\n        wheelTrail2.color1 = new BABYLON.Color4(0.1, 0.1, 0.1, 1);\n        wheelTrail2.color2 = new BABYLON.Color4(0.1, 0.1, 0.1, 1);\n        wheelTrail2.colorDead = new BABYLON.Color4(0, 0, 0, 0);\n      \n        // Set particle system properties\n        wheelTrail2.minSize = 0.8;\n        wheelTrail2.maxSize = 1.2;\n        wheelTrail2.minLifeTime = 1;\n        wheelTrail2.maxLifeTime = 1.6;\n        wheelTrail2.emitRate = 100;\n        wheelTrail2.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;\n        wheelTrail2.gravity = new BABYLON.Vector3(0, -4, 0);\n      \n        // Set particle system emitter to the other back wheel\n        const emitter2 = new BABYLON.Mesh(\"emitter2\", this.scene);\n        emitter2.parent = this.mesh;\n        emitter2.position = new BABYLON.Vector3(1.5, -1, -2.5);\n        //rotate emitter2 180 degrees\n        emitter2.rotationQuaternion = new BABYLON.Quaternion();\n        \n        wheelTrail2.emitter = emitter2;\n        wheelTrail2.minEmitBox = new BABYLON.Vector3(-0.1, 0, 0);\n        wheelTrail2.maxEmitBox = new BABYLON.Vector3(0.1, 0, 0);\n      \n        // Start the particle system\n        wheelTrail2.start();\n      \n        this.wheelTrail2 = wheelTrail2;\n      \n        return wheelTrail2;\n      }\n      createDashTrail() {\n        // Create particle system\n        const dashTrail = new BABYLON.ParticleSystem(\"dashTrail\", 200, this.scene);\n      \n        // Set particle texture and color\n        dashTrail.particleTexture = new BABYLON.Texture(\"../textures/star.png\", this.scene);\n\n        dashTrail.colorDead = new BABYLON.Color4(0, 0, 0, 0);\n        \n        // Set particle system properties\n        dashTrail.minSize = 1;\n        dashTrail.maxSize = 3;\n        dashTrail.minLifeTime = 1;\n        dashTrail.maxLifeTime = 1.6;\n        dashTrail.emitRate = 200;\n        dashTrail.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;\n        dashTrail.gravity = new BABYLON.Vector3(0, -1.8, 0);\n\n        //add direction1 and 2\n        dashTrail.direction1 = new BABYLON.Vector3(-2, 3, 7);\n        dashTrail.direction2 = new BABYLON.Vector3(7, 3, -2);\n        \n        // Set particle system emitter to the other back wheel\n        const emitter2 = new BABYLON.Mesh(\"emitter2\", this.scene);\n        emitter2.parent = this.mesh;\n        emitter2.position = new BABYLON.Vector3(0, -0.4, -2.5);\n        //rotate emitter2 180 degrees\n        emitter2.rotationQuaternion = new BABYLON.Quaternion();\n        \n        dashTrail.emitter = emitter2;\n        dashTrail.minEmitBox = new BABYLON.Vector3(-0.1, 0, 0);\n        dashTrail.maxEmitBox = new BABYLON.Vector3(0.1, 0, 0);\n        \n        // Start the particle system\n        dashTrail.start();\n        \n        this.dashTrail = dashTrail;\n        \n        return dashTrail;\n      }\n}\n\n//# sourceURL=webpack://my-app/./src/scripts/classes/Particles/particles.js?");

/***/ }),

/***/ "./src/scripts/classes/PhotonManager.js":
/*!**********************************************!*\
  !*** ./src/scripts/classes/PhotonManager.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PhotonManager\": () => (/* binding */ PhotonManager)\n/* harmony export */ });\nclass PhotonManager {\n  constructor() {\n    this.photon = new Photon.LoadBalancing.LoadBalancingClient(\n      Photon.ConnectionProtocol.Wss,\n      '63fffbcc-f982-4abc-96da-992658a15736', // Replace with your Photon App ID\n      '1.0' // Version\n    );\n    this.photon.setLogLevel(Exitgames.Common.Logger.Level.INFO);\n    this.photon.onEvent = this.onEvent.bind(this);\n    this.photon.onError = this.onError.bind(this);\n    this.photon.onStateChange = this.onStateChange.bind(this);\n    this.photon.onActorJoin = this.onActorJoin.bind(this);\n    this.photon.onActorLeave = this.onActorLeave.bind(this);\n    this.photon.onRoomList = this.onRoomList.bind(this);\n    this.playerPositions = new Map();\n    this.players = new Map();\n    this.localPlayerId = 0;\n  }\n  connect() {\n    this.photon.connectToRegionMaster('eu');\n  }\n  joinOrCreateRoom(roomName) {\n    const room = this.roomList.find(room => room.name === roomName);\n    if (room) {\n      console.log(\"room found, joining\");\n      this.photon.joinRoom(roomName);\n    } else {\n      console.log(\"room not found,creating\");\n      this.photon.createRoom(roomName, {\n        maxPlayers: 10, broadcastPropsChangeToAll: true\n      });\n    }\n  }\n  sendPlayerPositionUpdate(id, position, rotation, linearVelocity, angularVelocity) {\n    this.photon.raiseEvent(1, { id: id, position: position, rotation: rotation, linearVelocity: linearVelocity, angularVelocity: angularVelocity }, { receivers: Photon.LoadBalancing.Constants.ReceiverGroup.Others });\n    this.photon.myRoom().setCustomProperties({ [\"pos-\" + id.toString()]: position, [\"rot-\" + id.toString()]: rotation }, { webForward: true });\n  }\n  setOnPlayerPositionUpdate(callback) {\n    this.onPlayerPositionUpdate = callback;\n  }\n  setOnEvent(callback) {\n    this.onEvent += callback;\n  }\n  setOnJoinedRoom(callback) {\n    this.onJoinedRoom = callback;\n  }\n  onActorJoin(actor) {\n    // If the joining actor is the current client, no need to set its custom properties\n\n    if (this.actorJoinCallback) {\n      this.actorJoinCallback(actor);\n    }\n  }\n  onActorLeave(actor) {\n    if (this.actorLeaveCallback) {\n      this.actorLeaveCallback(actor);\n    }\n  }\n  setOnActorJoin(callback) {\n    this.actorJoinCallback = callback;\n  }\n  setOnActorLeave(callback) {\n    this.actorLeaveCallback = callback;\n  }\n  sendCollisionEvent(otherPlayerId) {\n    this.photon.raiseEvent(2, otherPlayerId);\n  }\n\n  receiveGameState(gameState) {\n    for (const playerState of gameState.players) {\n      const player = this.players.get(playerState.id);\n      if (player) {\n        player.correctState(playerState);\n      }\n    }\n  }\n  receiveCollisionEvent(otherPlayerId) {\n    const player = this.players.get(otherPlayerId);\n    if (player) {\n      player.handleCollision(otherPlayerId);\n    }\n  }\n  sendGameState() {\n    const gameState = {\n      players: Array.from(this.players.values()).map(player => player.getState())\n    };\n    this.photon.raiseEvent(3, gameState);\n  }\n\n  onEvent(code, data) {\n    if (code === 1) {\n      const { id, position, rotation, linearVelocity, angularVelocity } = data;\n      if (id.toString() !== this.photon.myActor().actorNr.toString()) {\n        // Update the position only for remote players\n        this.onPlayerPositionUpdate(id, position, rotation, linearVelocity, angularVelocity);\n      } else {\n        // Apply impulse force to the local player's vehicle when a collision occurs\n        const localPlayer = this.players.get(id.toString());\n        if (localPlayer) {\n          localPlayer.updatePhysicsBody(position, rotation, linearVelocity, angularVelocity, true);\n        }\n      }\n    }\n  }\n  onError(errorCode, errorMsg) {\n    console.error(`Photon Error: ${errorCode} - ${errorMsg}`);\n  }\n  onStateChange(state) {\n    if (state === Photon.LoadBalancing.LoadBalancingClient.State.JoinedLobby) {\n      // this.joinOrCreateRoom('test');\n    }\n    else if (state === Photon.LoadBalancing.LoadBalancingClient.State.Joined) {\n      this.onJoinedRoom();\n\n    }\n  }\n  onRoomList(rooms) {\n    console.log(rooms);\n    this.roomList = rooms;\n    this.joinOrCreateRoom(\"test232\");\n  }\n  getPing() {\n    this.photon.updateRtt(\"test232\");\n    return this.photon.getRtt();\n  }\n}\n\n//# sourceURL=webpack://my-app/./src/scripts/classes/PhotonManager.js?");

/***/ }),

/***/ "./src/scripts/classes/Player.js":
/*!***************************************!*\
  !*** ./src/scripts/classes/Player.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Player\": () => (/* binding */ Player)\n/* harmony export */ });\n/* harmony import */ var _ButtonsNDJoystick_Buttons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ButtonsNDJoystick/Buttons.js */ \"./src/scripts/classes/ButtonsNDJoystick/Buttons.js\");\n/* harmony import */ var _ButtonsNDJoystick_Joystick_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ButtonsNDJoystick/Joystick.js */ \"./src/scripts/classes/ButtonsNDJoystick/Joystick.js\");\n/* harmony import */ var _Particles_particles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Particles/particles.js */ \"./src/scripts/classes/Particles/particles.js\");\n\n\n\n\nclass Player {\n  constructor(scene, id, isLocal, position = new BABYLON.Vector3(0, 0, 0), rotation = new BABYLON.Quaternion()) {\n    console.log(position);\n    this.scene = scene;\n    this.engine = scene.getEngine();\n    this.id = id;\n    this.isLocal = isLocal;\n    this.position = position;\n    this.rotation = rotation;\n    this.speed = 0.05;\n    this.ZERO_QUATERNION = new BABYLON.Quaternion();\n    this.actions = { acceleration: false, braking: false, right: false, left: false, drift: false, boost: false, special: false, special2: false, special3: false };\n    this.mesh = null;\n    this.positionUpdated = false;\n    this.previousState = null;\n    this.respawnPosition = position.clone();\n    this.advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\n    this.specialActive = false;\n    this.special2Active = false;\n    this.engineForceMultiplier = 1;\n    this.lastSpecialTime = 0;\n    this.lastSpecial2Time = 0;\n    this.lastSpecial3Time = 0;\n    this.wheelMeshes = [];\n    this.gamebuttons = new _ButtonsNDJoystick_Buttons_js__WEBPACK_IMPORTED_MODULE_0__.Gamebuttons();\n    this.joystick = new _ButtonsNDJoystick_Joystick_js__WEBPACK_IMPORTED_MODULE_1__.Joystick();\n    this.particles = new _Particles_particles_js__WEBPACK_IMPORTED_MODULE_2__.Particle();\n    this.wheelTrail = null;\n    this.init();\n  }\n  updateActions(actions) {\n    this.actions = actions;\n  }\n  updatePhysicsBody(position, rotation, linearVelocity, angularVelocity, applyImpulse = false) {\n    if (this.body && !this.isLocal) {\n      const ammoPosition = new Ammo.btVector3(position.x, position.y, position.z);\n      const ammoRotation = new Ammo.btQuaternion(rotation.x, rotation.y, rotation.z, rotation.w);\n      const ammoTransform = new Ammo.btTransform();\n      ammoTransform.setIdentity();\n      ammoTransform.setOrigin(ammoPosition);\n      ammoTransform.setRotation(ammoRotation);\n      this.body.setWorldTransform(ammoTransform);\n      this.body.setMotionState(new Ammo.btDefaultMotionState(ammoTransform));\n      this.body.setLinearVelocity(linearVelocity);\n      this.body.setAngularVelocity(angularVelocity);\n      this.body.activate();\n      this.body.setCollisionFlags(2); // Set the CF_NO_CONTACT_RESPONSE flag to disable push response\n\n      if (applyImpulse) {\n        const impulse = linearVelocity.clone().multiplyScalar(this.body.getMass() * 2); // Adjust the multiplier as needed\n        const ammoImpulse = new Ammo.btVector3(impulse.x, impulse.y, impulse.z);\n        this.body.applyCentralImpulse(ammoImpulse);\n      }\n\n    } else {\n      console.warn(`Attempted to update physics body for player ${this.id} but body is not initialized`);\n    }\n  }\n  correctState(authoritativeState) {\n    this.state = authoritativeState;\n  }\n  handleCollision(otherPlayerId) {\n    const otherPlayer = this.players.get(otherPlayerId);\n    if (otherPlayer) {\n      // Calculate the new position and velocity after the collision\n      const newPosition = this.position.add(this.velocity);\n      const newVelocity = this.velocity.subtract(otherPlayer.velocity);\n      // Update the player's state\n      this.state.position = newPosition;\n      this.state.velocity = newVelocity;\n    }\n  }\n  predictCollision(otherPlayerId) {\n    const otherPlayer = this.players.get(otherPlayerId);\n    if (otherPlayer) {\n      // Predict the new position and velocity after the collision\n      const predictedPosition = this.position.add(this.velocity);\n      const predictedVelocity = this.velocity.subtract(otherPlayer.velocity);\n      // Update the player's state\n      this.state.position = predictedPosition;\n      this.state.velocity = predictedVelocity;\n    }\n  }\n  updatePhysicsBodyRotation(rotation) {\n    if (this.body) {\n      const ammoRotation = new Ammo.btQuaternion(rotation.x, rotation.y, rotation.z, rotation.w);\n      const ammoTransform = this.body.getCenterOfMassTransform();\n      ammoTransform.setRotation(ammoRotation);\n      this.body.setCenterOfMassTransform(ammoTransform);\n    } else {\n      console.warn(`Attempted to update physics body rotation for player ${this.id} but body is not initialized`);\n    }\n  }\n\n  getState() {\n    return {\n      id: this.id,\n      position: this.position.clone(),\n      rotation: this.rotation.clone(),\n      actions: { ...this.actions },\n      speed: this.speed,\n      specialActive: this.specialActive,\n      special2Active: this.special2Active,\n      engineForceMultiplier: this.engineForceMultiplier,\n      lastSpecialTime: this.lastSpecialTime,\n      lastSpecial2Time: this.lastSpecial2Time,\n      lastSpecial3Time: this.lastSpecial3Time,\n    };\n  }\n\n  init() {\n    this.mesh = this.createVehicle(this.position, this.rotation);\n    this.mesh.position = this.position;\n    this.mesh.rotationQuaternion = this.rotation;\n    this.positionUpdated = false;\n    this.boostParticles = this.particles.createBoostParticles.call(this);\n\n    this.freezeEffect = this.particles.createFreezeEffectParticleSystem.call(this);\n    this.freezeEffect.stop();\n\n    this.wheelTrail = this.particles.createWheelTrail.call(this);\n    this.wheelTrail.stop();\n\n    this.wheelTrail2 = this.particles.createWheelTrail2.call(this);\n    this.wheelTrail2.stop();\n\n    this.dashTrail = this.particles.createDashTrail.call(this);\n    this.dashTrail.stop();\n\n    this.wheelSmokeTrail = this.particles.createWheelSmokeTrail.call(this);\n    this.wheelSmokeTrail.stop();\n\n    this.weightEffect = this.particles.createWeightEffectParticleSystem.call(this);\n    this.weightEffect.stop();\n\n    console.log(\"player \" + this.id + \" created\");\n    if (this.isLocal) {\n      if (/Mobi|Android/i.test(navigator.userAgent)) {\n        // Mobile device detected\n        this.joystick.createJoystick.call(this);\n        this.gamebuttons.createButtons.call(this);\n        this.setupControls();\n      }\n      this.joystick.createJoystick.call(this);\n      this.gamebuttons.createButtons.call(this);\n      this.setupControls();\n    }\n    else {\n      // this.mesh.physicsImpostor.setMass(400);\n    }\n    var box = new BABYLON.MeshBuilder.CreateBox(\"box\", { width: 1, depth: 1, height: 1 }, this.scene);\n    box.position.set(1, 1, 1);\n    box.rotation.set(1, 1, 1);\n    box.position.y += 5;\n    box.physicsImpostor = new BABYLON.PhysicsImpostor(box, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, friction: 0.5, restitution: 0.7 }, this.scene);\n\n    return this.mesh;\n  }\n\n  respawn() {\n    var transform = new Ammo.btTransform();\n    transform.setIdentity();\n    transform.setOrigin(new Ammo.btVector3(0, 0, 0));\n    transform.setRotation(new Ammo.btQuaternion(0, 0, 0, 1));\n    this.body.setCenterOfMassTransform(transform);\n    this.body.setLinearVelocity(new Ammo.btVector3(0, 0, 0));\n    this.body.setAngularVelocity(new Ammo.btVector3(0, 0, 0));\n    this.body.activate();\n  }\n\n  createVehicle(pos, quat) {\n    const addWheel = (isFront, pos, radius, width, index) => {\n      var wheelInfo = vehicle.addWheel(\n        pos,\n        wheelDirectionCS0,\n        wheelAxleCS,\n        suspensionRestLength,\n        radius,\n        tuning,\n        isFront);\n      if (!isFront) {\n        wheelInfo.set_m_frictionSlip(driftFriction);\n      }\n      wheelInfo.set_m_suspensionStiffness(suspensionStiffness);\n      wheelInfo.set_m_wheelsDampingRelaxation(suspensionDamping);\n      wheelInfo.set_m_wheelsDampingCompression(suspensionCompression);\n      wheelInfo.set_m_maxSuspensionForce(200000);\n      wheelInfo.set_m_frictionSlip(10);\n      wheelInfo.set_m_rollInfluence(rollInfluence);\n\n\n      var wheelMaterial = new BABYLON.StandardMaterial(\"wheelMaterial\");\n      wheelMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);\n\n      this.wheelMeshes[index] = createWheelMesh(radius, width);\n      if (isFront) {\n        var wheelMaterial = new BABYLON.StandardMaterial(\"wheelMaterial\");\n        wheelMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);\n        this.wheelMeshes[index].material = wheelMaterial;\n      }\n    }\n\n    function createWheelMesh(radius, width) {\n      //var mesh = new BABYLON.MeshBuilder.CreateBox(\"wheel\", {width:.82, height:.82, depth:.82});\n      var mesh = new BABYLON.MeshBuilder.CreateCylinder(\"Wheel\", { diameter: 1.5, height: 0.8, tessellation: 12 });\n      mesh.rotationQuaternion = new BABYLON.Quaternion();\n      return mesh;\n    }\n\n    function createChassisMesh(w, l, h, color) {\n      var mesh = new BABYLON.MeshBuilder.CreateBox(\"box\", { width: w, depth: h, height: l });\n      mesh.rotationQuaternion = new BABYLON.Quaternion();\n\n      var chassisMaterial = new BABYLON.StandardMaterial(\"chassisMaterial\");\n      chassisMaterial.diffuseColor = color;\n      mesh.material = chassisMaterial;\n\n      return mesh;\n    }\n\n    var vehicle, chassisMesh, wheelDirectionCS0, wheelAxleCS, vehicleReady = false;\n\n    var chassisWidth = 1.8;\n    var chassisHeight = .6;\n    var chassisLength = 4;\n    var massVehicle = 400;//200\n\n    var wheelAxisPositionBack = -2;\n    var wheelRadiusBack = .8;\n    var wheelWidthBack = .6;\n    var wheelHalfTrackBack = 1.5;\n    var wheelAxisHeightBack = 0.4;\n\n    var wheelAxisFrontPosition = 2.0;\n    var wheelHalfTrackFront = 1.5;\n    var wheelAxisHeightFront = 0.4;\n    var wheelRadiusFront = .8;\n    var wheelWidthFront = .6;\n\n    var friction = 5;\n    var suspensionStiffness = 20;\n    var suspensionDamping = 1;\n    var suspensionCompression = 2;\n    var suspensionRestLength = 0.6;\n    var rollInfluence = -0.2;\n\n    var steeringIncrement = .01;\n    var steeringClamp = 0.4;\n    var maxEngineForce = 3000;\n    var maxBreakingForce = 20;\n    var incEngine = 10.0;\n    var driftBreakingForce = 7;\n\n    var FRONT_LEFT = 0;\n    var FRONT_RIGHT = 1;\n    var BACK_LEFT = 2;\n    var BACK_RIGHT = 3;\n\n    var driftFriction = 40;\n\n    var physicsWorld = this.scene.getPhysicsEngine().getPhysicsPlugin().world;\n\n    var wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0);\n    var wheelAxleCS = new Ammo.btVector3(-1, 0, 0);\n\n    var localPlayerColor = new BABYLON.Color3(1, 1, 0); // Yellow\n    var otherPlayerColor = new BABYLON.Color3(1, 0, 0); // Red\n\n    var geometry = new Ammo.btBoxShape(new Ammo.btVector3(chassisWidth * 1, chassisHeight * 1, chassisLength * 0.75));\n    var transform = new Ammo.btTransform();\n    transform.setIdentity();\n    transform.setOrigin(new Ammo.btVector3(this.position.x, this.position.y, this.position.x));\n    transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));\n    var motionState = new Ammo.btDefaultMotionState(transform);\n    var localInertia = new Ammo.btVector3(0, 0, 0);\n    geometry.calculateLocalInertia(massVehicle, localInertia);\n\n    chassisMesh = createChassisMesh(chassisWidth * 1.5, chassisHeight * 1.5, chassisLength * 1.5, this.isLocal ? localPlayerColor : otherPlayerColor);\n\n    var massOffset = new Ammo.btVector3(0, 0.4, 0);\n    var transform2 = new Ammo.btTransform();\n    transform2.setIdentity();\n    transform2.setOrigin(massOffset);\n    var compound = new Ammo.btCompoundShape();\n    compound.addChildShape(transform2, geometry);\n    compound.position = this.position;\n    var body = new Ammo.btRigidBody(new Ammo.btRigidBodyConstructionInfo(massVehicle, motionState, compound, localInertia));\n    body.setActivationState(4);\n\n    this.body = body;\n\n    physicsWorld.addRigidBody(body);\n\n    var engineForce = 0;\n    var vehicleSteering = 0;\n    var breakingForce = 0;\n    var tuning = new Ammo.btVehicleTuning();\n    var rayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld);\n    vehicle = new Ammo.btRaycastVehicle(tuning, body, rayCaster);\n    vehicle.setCoordinateSystem(0, 1, 2);\n    physicsWorld.addAction(vehicle);\n\n    var trans = vehicle.getChassisWorldTransform();\n    trans.setOrigin(new Ammo.btVector3(this.position.x, this.position.y, this.position.z));\n    //vehicle.setChassisWorldTransform(trans);\n\n    addWheel(true, new Ammo.btVector3(wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_LEFT);\n    addWheel(true, new Ammo.btVector3(-wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_RIGHT);\n    addWheel(false, new Ammo.btVector3(-wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_LEFT);\n    addWheel(false, new Ammo.btVector3(wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_RIGHT);\n\n    vehicleReady = true;\n\n    this.scene.registerBeforeRender(() => {\n      // var dt = this.engine.getDeltaTime().toFixed() / 1000;,\n\n      if (vehicleReady) {\n        var speed = vehicle.getCurrentSpeedKmHour();\n        var maxSteerVal = 0.2;\n        breakingForce = 0;\n        engineForce = 0;\n\n        if (this.actions.acceleration) {\n          if (speed < -1) {\n            breakingForce = maxBreakingForce;\n          } else {\n            engineForce = maxEngineForce;\n          }\n        } else if (this.actions.braking) {\n          if (speed > 1) {\n            breakingForce = maxBreakingForce;\n          } else {\n            engineForce = -maxEngineForce;\n          }\n        }\n        if (this.actions.right) {\n          if (vehicleSteering < steeringClamp) {\n            vehicleSteering += steeringIncrement;\n          }\n        } else if (this.actions.left) {\n          if (vehicleSteering > -steeringClamp) {\n            vehicleSteering -= steeringIncrement;\n          }\n        } else {\n          vehicleSteering = 0;\n        }\n        if (this.actions.drift) {\n          driftFriction = 5;\n          breakingForce += driftBreakingForce * 6;\n          this.wheelTrail.start();\n          this.wheelTrail2.start();\n          this.wheelSmokeTrail.start();\n        } else {\n          driftFriction = 40;\n          this.wheelTrail.stop();\n          this.wheelTrail2.stop();\n          this.wheelSmokeTrail.stop();\n        }\n        if (this.actions.boost) {\n          engineForce = maxEngineForce * 1.6;\n          if (!this.boostParticles.isStarted()) {\n            this.boostParticles.start();\n          }\n        } else {\n          if (this.boostParticles.isStarted()) {\n            this.boostParticles.stop();\n          }\n        }\n\n        if (this.actions.special && !this.specialActive) {\n          // Mark special as active\n          this.specialActive = true;\n          this.engineForceMultiplier = 0;\n\n          // Apply a large braking force to all wheels\n          vehicle.setBrake(10000, FRONT_LEFT);\n          vehicle.setBrake(10000, FRONT_RIGHT);\n          vehicle.setBrake(10000, BACK_LEFT);\n          vehicle.setBrake(10000, BACK_RIGHT);\n\n          // Set the car's linear and angular velocity to zero\n          const linearVelocity = this.body.getLinearVelocity();\n          linearVelocity.setValue(0, 0, 0);\n          this.body.setLinearVelocity(linearVelocity);\n\n          const angularVelocity = this.body.getAngularVelocity();\n          angularVelocity.setValue(0, 0, 0);\n          this.body.setAngularVelocity(angularVelocity);\n\n          if (!this.freezeEffect.isStarted()) {\n            this.freezeEffect.start();\n          }\n\n          // Set a timer to release the brakes and restore the car's control after 2 seconds\n          setTimeout(() => {\n            vehicle.setBrake(0, FRONT_LEFT);\n            vehicle.setBrake(0, FRONT_RIGHT);\n            vehicle.setBrake(0, BACK_LEFT);\n            vehicle.setBrake(0, BACK_RIGHT);\n\n            if (this.freezeEffect.isStarted()) {\n              this.freezeEffect.stop();\n            }\n\n            // Mark special as inactive\n            this.specialActive = false;\n            this.engineForceMultiplier = 1;\n          }, 2000);\n        }\n\n        if (this.actions.special2 && !this.special2Active) {\n          // Mark special2 as active\n          this.special2Active = true;\n\n          // Increase the car's mass by a factor of 10\n          const massFactor = 10;\n          const originalMass = massVehicle;\n          const increasedMass = originalMass * massFactor;\n          this.body.setMassProps(increasedMass, localInertia);\n\n          // Set the car's linear and angular velocity to zero\n          const linearVelocity = this.body.getLinearVelocity();\n          linearVelocity.setValue(0, 0, 0);\n          this.body.setLinearVelocity(linearVelocity);\n\n          const angularVelocity = this.body.getAngularVelocity();\n          angularVelocity.setValue(0, 0, 0);\n          this.body.setAngularVelocity(angularVelocity);\n\n          this.weightEffect.start();\n\n          // Set a timer to reset the mass after 2 seconds\n          setTimeout(() => {\n            // Reset the car's mass to the original value\n            this.body.setMassProps(originalMass, localInertia);\n\n            // Release the brakes after a short delay\n            setTimeout(() => {\n              vehicle.setBrake(0, FRONT_LEFT);\n              vehicle.setBrake(0, FRONT_RIGHT);\n              vehicle.setBrake(0, BACK_LEFT);\n              vehicle.setBrake(0, BACK_RIGHT);\n              this.weightEffect.stop();\n              // Mark special2 as inactive\n              this.special2Active = false;\n            }, 200);\n          }, 2000);\n\n        }\n\n        if (this.actions.special3 && !this.special3Active) {\n          // Mark special3 as active\n          this.special3Active = true;\n\n          // Calculate the current speed and movement direction\n          const speed = vehicle.getCurrentSpeedKmHour() / 3.6;\n          const movementDirection = vehicle.getForwardVector();\n\n          // Calculate the extra force for the quick dash\n          const dashForce = 50000;\n\n          // Apply the dash force to the vehicle\n          const impulse = new Ammo.btVector3(movementDirection.x() * dashForce, 0, movementDirection.z() * dashForce);\n          this.body.applyCentralImpulse(impulse);\n\n          this.dashTrail.start();\n\n          // Set a timer to mark special3 as inactive after a short delay\n          setTimeout(() => {\n            this.special3Active = false;\n            const stopImpulse = new Ammo.btVector3(0, 0, 0);\n            this.body.setLinearVelocity(stopImpulse);\n            this.dashTrail.stop();\n          }, 200);\n        }\n\n        vehicle.getWheelInfo(BACK_LEFT).set_m_frictionSlip(driftFriction / 1.1);\n        vehicle.getWheelInfo(BACK_RIGHT).set_m_frictionSlip(driftFriction / 1.1);\n        vehicle.getWheelInfo(FRONT_LEFT).set_m_frictionSlip(driftFriction);\n        vehicle.getWheelInfo(FRONT_RIGHT).set_m_frictionSlip(driftFriction);\n\n        vehicle.applyEngineForce(engineForce * this.engineForceMultiplier, FRONT_LEFT);\n        vehicle.applyEngineForce(engineForce * this.engineForceMultiplier, FRONT_RIGHT);\n\n        vehicle.setBrake(breakingForce / 2, FRONT_LEFT);\n        vehicle.setBrake(breakingForce / 2, FRONT_RIGHT);\n        vehicle.setBrake(breakingForce, BACK_LEFT);\n        vehicle.setBrake(breakingForce, BACK_RIGHT);\n\n        vehicle.setSteeringValue(vehicleSteering, FRONT_LEFT);\n        vehicle.setSteeringValue(vehicleSteering, FRONT_RIGHT);\n\n        var tm, p, q, i;\n        var n = vehicle.getNumWheels();\n        for (i = 0; i < n; i++) {\n          vehicle.updateWheelTransform(i, true);\n          tm = vehicle.getWheelTransformWS(i);\n          p = tm.getOrigin();\n          q = tm.getRotation();\n          this.wheelMeshes[i].position.set(p.x(), p.y(), p.z());\n          this.wheelMeshes[i].rotationQuaternion.set(q.x(), q.y(), q.z(), q.w());\n          this.wheelMeshes[i].rotate(BABYLON.Axis.Z, Math.PI / 2);\n        }\n\n        tm = vehicle.getChassisWorldTransform();\n        p = tm.getOrigin();\n        q = tm.getRotation();\n        chassisMesh.position.set(p.x(), p.y(), p.z());\n        chassisMesh.rotationQuaternion.set(q.x(), q.y(), q.z(), q.w());\n        //chassisMesh.rotate(BABYLON.Axis.X, Math.PI);\n      }\n      if (chassisMesh.position.y < -5 || chassisMesh.position.y > 20) {\n        this.respawn();\n      }\n    });\n\n    return chassisMesh;\n  }\n\n  setupControls() {\n\n  }\n\n  moveForward() {\n    this.mesh.position.z -= this.speed;\n  }\n\n  moveBackward() {\n    this.mesh.position.z += this.speed;\n  }\n\n  moveLeft() {\n    this.mesh.position.x -= this.speed;\n  }\n\n  moveRight() {\n    this.mesh.position.x += this.speed;\n  }\n\n  updatePosition(position) {\n    this.mesh.position = position;\n  }\n\n  destroy() {\n    if (this.body) {\n      const physicsEngine = this.scene.getPhysicsEngine();\n      const physicsWorld = physicsEngine.getPhysicsPlugin().world;\n      physicsWorld.removeRigidBody(this.body);\n      this.body = null;\n    }\n    if (this.vehicle) {\n      this.scene.getPhysicsEngine().removeAction(this.vehicle);\n      this.vehicle = null;\n    }\n    if (this.mesh) {\n      this.wheelMeshes.forEach((wheelMesh) => { wheelMesh.dispose() });\n      this.mesh.dispose();\n      this.mesh = null;\n      console.log(`Player ${this.id} destroyed`);\n    } else {\n      console.warn(`Attempted to destroy player ${this.id} but mesh is not initialized`);\n    }\n  }\n}\n\n//# sourceURL=webpack://my-app/./src/scripts/classes/Player.js?");

/***/ }),

/***/ "./src/scripts/scenes/game2.js":
/*!*************************************!*\
  !*** ./src/scripts/scenes/game2.js ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _classes_Player_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/Player.js */ \"./src/scripts/classes/Player.js\");\n/* harmony import */ var _classes_PhotonManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/PhotonManager.js */ \"./src/scripts/classes/PhotonManager.js\");\n\n// Import the classes\n\n\n\n// Create the Babylon.js engine and scene\nconst canvas = document.getElementById('renderCanvas');\nconst engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, adaptToDeviceRatio: true });\nconst scene = new BABYLON.Scene(engine);\n\nlet divFps = document.getElementById(\"debug\");\nlet ping = 0;\n\nawait Ammo();\n\nscene.enablePhysics(new BABYLON.Vector3(0, -20, 0), new BABYLON.AmmoJSPlugin(true, Ammo));\n\n\n\nlet localPlayer = null;\nscene.clearColor = new BABYLON.Color3(0.8, 0.8, 0.8);\n\nconst groundRadius = 45;\nconst ground = BABYLON.MeshBuilder.CreateDisc('ground', { radius: groundRadius, tessellation: 64 }, scene);\nconst groundMaterial = new BABYLON.GridMaterial('groundMaterial', scene);\ngroundMaterial.mainColor = new BABYLON.Color3(0.4, 0.4, 0.4);\ngroundMaterial.lineColor = new BABYLON.Color3(0.2, 0.2, 0.2);\nground.material = groundMaterial;\n\nground.position.z = -1;\n\nconst groundPhysicsOptions = {\n  mass: 0,\n  friction: 0.5,\n  restitution: 0.7,\n  shape: BABYLON.PhysicsImpostor.CylinderImpostor,\n  nativeOptions: {\n    radiusTop: groundRadius,\n    radiusBottom: groundRadius,\n    height: 0.01,\n    numSegments: 64,\n    mass: 0\n  }\n};\nground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.MeshImpostor, groundPhysicsOptions, scene);\n\nground.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);\n\nconst camera = new BABYLON.ArcRotateCamera(\"camera1\", Math.PI / 2, 2.1, -24, new BABYLON.Vector3(0, 0, 0), scene);\ncamera.setPosition(new BABYLON.Vector3(0, 35, 65));\ncamera.setTarget(new BABYLON.Vector3(0, 0, 20));\ncamera.fov = 0.9;\n\n//camera.attachControl(canvas, true);\ncamera.inputs.removeByType(\"ArcRotateCameraKeyboardMoveInput\");\ncamera.inputs.removeByType(\"ArcRotateCameraMouseWheelInput\");\ncamera.inputs.removeByType(\"ArcRotateCameraPointersInput\");\n\nconst light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);\nconst players = new Map();\n\nconst photonManager = new _classes_PhotonManager_js__WEBPACK_IMPORTED_MODULE_1__.PhotonManager();\n\nphotonManager.setOnJoinedRoom(() => {\n  const randomX = Math.random() * (groundRadius * 2) - groundRadius;\n  const randomZ = Math.random() * (groundRadius * 2) - groundRadius;\n\n  // Add the local player\n  localPlayer = new _classes_Player_js__WEBPACK_IMPORTED_MODULE_0__.Player(scene, photonManager.photon.myActor().actorNr, true, new BABYLON.Vector3(randomX, 0, randomZ)); players.set(photonManager.photon.myActor().actorNr.toString(), localPlayer);\n  photonManager.localPlayerId = localPlayer.id;\n\n  const otherActors = photonManager.photon.myRoomActors();\n  if (localPlayer.id === photonManager.localPlayerId) {\n\n    window.addEventListener('keydown', keydown);\n    window.addEventListener('keyup', keyup);\n  }\n  console.log(\"my actor nr \" + photonManager.photon.myActor().actorNr);\n  for (var i = 1; i <= otherActors.length; i++) {\n    console.log(otherActors[i].actorNr);\n  }\n\n  for (var actor in otherActors) {\n    if (actor.toString() !== photonManager.photon.myActor().actorNr.toString()) {\n      const cp = photonManager.photon.myRoom().getCustomProperties();\n      for (const id in cp) {\n        if (id == \"pos-\" + actor.toString()) {\n          var otherPlayerPosition = cp[id];\n          var otherPlayerRotation = cp[\"rot-\" + actor.toString()];\n          break;\n        }\n      }\n      // Create the other player using their last known position\n      const otherPlayer = new _classes_Player_js__WEBPACK_IMPORTED_MODULE_0__.Player(scene, actor, false, new BABYLON.Vector3(otherPlayerPosition._x, otherPlayerPosition._y, otherPlayerPosition._z), new BABYLON.Quaternion(otherPlayerRotation._w, otherPlayerRotation._x, otherPlayerRotation._y, otherPlayerRotation._z));\n      console.log(otherPlayer);\n      players.set(actor.toString(), otherPlayer);\n    }\n  }\n  photonManager.players = players;\n});\n\nphotonManager.setOnActorJoin((actor) => {\n\n  console.log(\"actor joined \" + photonManager.photon.myActor().actorNr + \" \" + actor.actorNr);\n  if (photonManager.photon.myActor().actorNr == actor.actorNr) {\n    return;\n  }\n\n\n  const newposition = new BABYLON.Vector3(0, 0, 0);\n  const newrotation = new BABYLON.Quaternion();\n\n  // Check if there is an existing player with the same actor number\n  const existingPlayer = photonManager.playerPositions.get(actor.actorNr.toString());\n  if (existingPlayer) {\n    newposition._x = existingPlayer.x;\n    newposition._y = existingPlayer.y;\n    newposition._z = existingPlayer.z;\n    newrotation._w = existingPlayer.w;\n    newrotation._x = existingPlayer.x;\n    newrotation._y = existingPlayer.y;\n    newrotation._z = existingPlayer.z;\n  }\n\n\n  // Set the custom properties for the joining actor\n  photonManager.photon.myRoom().setCustomProperties({ [`pos-${actor.actorNr}`]: newposition, [`rot-${actor.actorNr}`]: newrotation }, { webForward: true });\n\n  const newPlayer = new _classes_Player_js__WEBPACK_IMPORTED_MODULE_0__.Player(scene, actor.actorNr, false, newposition, newrotation);\n  players.set(actor.actorNr.toString(), newPlayer);\n\n  photonManager.players.set(actor.actorNr.toString(), newPlayer);\n  console.log(\"new player joined\" + actor);\n});\n\nfunction detectCollision(player1, player2) {\n  const body1 = player1.body;\n  const body2 = player2.body;\n  const transform1 = new Ammo.btTransform();\n  body1.getMotionState().getWorldTransform(transform1);\n  const transform2 = new Ammo.btTransform();\n  body2.getMotionState().getWorldTransform(transform2);\n  const origin1 = transform1.getOrigin();\n  const origin2 = transform2.getOrigin();\n  const dx = origin1.x() - origin2.x();\n  const dy = origin1.y() - origin2.y();\n  const dz = origin1.z() - origin2.z();\n  const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n  const radius1 = player1.mesh.getBoundingInfo().boundingSphere.radiusWorld;\n  const radius2 = player2.mesh.getBoundingInfo().boundingSphere.radiusWorld;\n  return distance <= radius1 + radius2;\n}\n\n\nphotonManager.setOnActorLeave((actor) => {\n  const playerToRemove = players.get(actor.actorNr.toString());\n  console.log(actor)\n  console.log(playerToRemove)\n  if (playerToRemove) {\n    playerToRemove.destroy();\n    players.delete(actor.actorNr.toString());\n  }\n  photonManager.players = players;\n});\nphotonManager.connect();\n\nsetInterval(() => {\n  ping = photonManager.getPing();\n  photonManager.sendGameState();\n}, 1000);\nvar collision = false;\nsetInterval(() => {\n  if (localPlayer != null) {\n    const position = localPlayer.mesh.position;\n    const rotation = localPlayer.mesh.rotationQuaternion;\n\n    if (localPlayer.id === photonManager.localPlayerId) {\n\n      photonManager.players.forEach((player) => {\n\n\n        if (localPlayer.id != player.id) {\n          var otherPlayerColl = player;\n          if (detectCollision(localPlayer, otherPlayerColl)) {\n            photonManager.sendCollisionEvent(otherPlayerColl.id);\n          }\n        }\n\n      });\n\n      //photonManager.photon.myRoom().setCustomProperty(\"pos-\" + photonManager.photon.myActor().actorNr.toString(), position);\n      photonManager.sendPlayerPositionUpdate(localPlayer.id, position, rotation, localPlayer.body.getLinearVelocity(), localPlayer.body.getAngularVelocity());\n    }\n    // photonManager.photon.raiseEvent(Photon.LoadBalancing.Constants.EventCode.UserCustom, data);\n  }\n\n\n}, 10);\n// Set up the main game loop\nengine.runRenderLoop(() => {\n\n  divFps.innerHTML = engine.getFps().toFixed() + \" fps\";\n  divFps.innerHTML += \"<br/>\" + `${ping} ms`;\n\n\n  scene.render();\n});\n\nphotonManager.setOnEvent((event) => {\n  if (event.Code === 3) {\n    const gameState = event.Parameters;\n    photonManager.receiveGameState(gameState);\n    for (const playerState of gameState.players) {\n      const player = players.get(playerState.id);\n      if (player) {\n        player.setState(playerState);\n      }\n    }\n  }\n  if (event.Code === 2) {\n    const otherPlayerId = event.Parameters;\n    photonManager.receiveCollisionEvent(otherPlayerId);\n  }\n});\nphotonManager.setOnPlayerPositionUpdate((id, position, rotation, linearVelocity, angularVelocity) => {\n  const otherPlayer = players.get(id.toString());\n\n  function interpolate(vector1, vector2, t) {\n    return BABYLON.Vector3.Lerp(vector1, vector2, t);\n  }\n\n  function interpolateRotation(quaternion1, quaternion2, t) {\n    return BABYLON.Quaternion.Slerp(quaternion1, quaternion2, t);\n  }\n\n  const interpolatePlayer = (player, newPosition, newRotation, interpolationTime, linearVelocity, angularVelocity) => {\n    const currentTime = Date.now();\n    const previousState = player.previousState;\n    const targetState = { position: newPosition, rotation: newRotation, timestamp: currentTime };\n    const smoothingFactor = 0.1; // You can adjust this value to control the smoothing\n\n\n    if (previousState) {\n      const deltaTime = currentTime - previousState.timestamp;\n      const t = Math.min(deltaTime / interpolationTime, 1);\n      const interpolatedPosition = interpolate(previousState.position, targetState.position, t);\n      const interpolatedRotation = interpolateRotation(previousState.rotation, targetState.rotation, t);\n\n      // Apply smoothing to the interpolated position and rotation\n      const smoothedPosition = BABYLON.Vector3.Lerp(player.mesh.position, interpolatedPosition, smoothingFactor);\n      const smoothedRotation = BABYLON.Quaternion.Slerp(player.mesh.rotationQuaternion, interpolatedRotation, smoothingFactor);\n\n      player.updatePosition(smoothedPosition);\n      player.updatePhysicsBodyRotation(smoothedRotation);\n      player.updatePhysicsBody(smoothedPosition, smoothedRotation, linearVelocity, angularVelocity);\n\n      // Update the previous state for the player\n      player.previousState.position = interpolatedPosition.clone();\n      player.previousState.rotation = interpolatedRotation.clone();\n      player.previousState.timestamp = currentTime;\n    } else {\n      player.updatePosition(newPosition);\n      player.updatePhysicsBodyRotation(newRotation);\n      player.updatePhysicsBody(newPosition, newRotation, linearVelocity, angularVelocity);\n      // Set the previous state for the player\n      player.previousState = { position: newPosition.clone(), rotation: newRotation.clone(), timestamp: currentTime };\n    }\n\n    // Update the physics body position for other players\n    if (player !== localPlayer) {\n      player.updatePhysicsBody(newPosition, newRotation, linearVelocity, angularVelocity);\n    }\n\n    photonManager.playerPositions.set(player.id.toString(), { position: newPosition.clone(), rotation: newRotation.clone(), timestamp: Date.now() });\n  };\n\n  if (otherPlayer) {\n    const newPosition = new BABYLON.Vector3(position._x, position._y, position._z);\n    const newRotation = new BABYLON.Quaternion(rotation._x, rotation._y, rotation._z, rotation._w);\n    const interpolationTime = 100; // Adjust this value to control the interpolation speed\n    interpolatePlayer(otherPlayer, newPosition, newRotation, interpolationTime, linearVelocity, angularVelocity);\n  } else if (localPlayer) {\n    // Client-side prediction for the local player\n    localPlayer.updatePhysicsBody(position, rotation, linearVelocity, angularVelocity);\n  }\n});\n\n\n\nvar keysActions = {\n  \"KeyW\": 'acceleration',\n  \"KeyS\": 'braking',\n  \"KeyA\": 'left',\n  \"KeyD\": 'right',\n  \"Space\": 'drift',\n  \"ShiftLeft\": 'boost',\n  \"KeyE\": 'special',\n  \"KeyR\": 'special2',\n  \"KeyQ\": 'special3',\n};\n\nfunction keydown(e) {\n\n  if (keysActions[e.code]) {\n    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {\n      localPlayer.actions['boost'] = true;\n    } else {\n      localPlayer.actions[keysActions[e.code]] = true;\n    }\n    localPlayer.updateActions(localPlayer.actions);\n\n  }\n}\n\nfunction keyup(e) {\n\n  console.log(localPlayer);\n  if (keysActions[e.code]) {\n    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {\n      localPlayer.actions['boost'] = false;\n    } else {\n      localPlayer.actions[keysActions[e.code]] = false;\n    }\n    localPlayer.updateActions(localPlayer.actions);\n\n  }\n}\n\n// Handle window resizing\nwindow.addEventListener('resize', () => {\n  engine.resize();\n});\n\nfunction hideLoadingScreen() {\n  const loadingScreen = document.getElementById('loading-screen');\n  loadingScreen.style.display = 'none';\n}\n\nsetTimeout(hideLoadingScreen, 100);\n\nfunction isMobileDevice() {\n  return typeof window.orientation !== \"undefined\" || navigator.userAgent.indexOf(\"IEMobile\") !== -1;\n}\n\nfunction updateOrientation() {\n  if (!isMobileDevice()) return;\n  const orientationWarning = document.getElementById('orientation-warning');\n  const canvas = document.getElementById('renderCanvas');\n\n  if (window.orientation === 90 || window.orientation === -90) {\n    orientationWarning.style.display = 'none';\n    canvas.style.display = 'block';\n  } else {\n    orientationWarning.style.display = 'block';\n    canvas.style.display = 'none';\n  }\n\n  engine.resize();\n}\n\n// Listen for orientation changes\nwindow.addEventListener('orientationchange', updateOrientation);\n\n// Update the orientation when the page loads\nupdateOrientation();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://my-app/./src/scripts/scenes/game2.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && !queue.d) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = 1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./src/scripts/classes/Player.js");
/******/ 	__webpack_require__("./src/scripts/classes/PhotonManager.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/scripts/scenes/game2.js");
/******/ 	
/******/ })()
;