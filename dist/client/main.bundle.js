/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/scripts/classes/PhotonManager.js":
/*!**********************************************!*\
  !*** ./src/scripts/classes/PhotonManager.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PhotonManager\": () => (/* binding */ PhotonManager)\n/* harmony export */ });\nclass PhotonManager {\r\n    constructor() {\r\n        this.photon = new Photon.LoadBalancing.LoadBalancingClient(\r\n            Photon.ConnectionProtocol.Wss,\r\n            '63fffbcc-f982-4abc-96da-992658a15736', // Replace with your Photon App ID\r\n            '1.0' // Version\r\n        );\r\n        this.photon.setLogLevel(Exitgames.Common.Logger.Level.INFO);\r\n        this.photon.onEvent = this.onEvent.bind(this);\r\n        this.photon.onError = this.onError.bind(this);\r\n        this.photon.onStateChange = this.onStateChange.bind(this);\r\n        this.photon.onActorJoin = this.onActorJoin.bind(this);\r\n        this.photon.onActorLeave = this.onActorLeave.bind(this);\r\n        this.photon.onRoomList = this.onRoomList.bind(this);\r\n        this.playerPositions = new Map();\r\n\r\n    }\r\n    connect() {\r\n        this.photon.connectToRegionMaster('eu');\r\n    }\r\n    joinOrCreateRoom(roomName) {\r\n        const room = this.roomList.find(room => room.name === roomName);\r\n        if (room) {\r\n            console.log(\"room found, joining\");\r\n            this.photon.joinRoom(roomName);\r\n        } else {\r\n            console.log(\"room not found,creating\");\r\n            this.photon.createRoom(roomName, {\r\n                maxPlayers: 10, broadcastPropsChangeToAll: true\r\n            });\r\n        }\r\n    }\r\n\r\n    sendPlayerPositionUpdate(id, position, rotation) {\r\n        this.photon.raiseEvent(1, { id: id, position: position, rotation: rotation }, { receivers: Photon.LoadBalancing.Constants.ReceiverGroup.Others });\r\n        this.photon.myRoom().setCustomProperties({ [\"pos-\" + id.toString()]: position, [\"rot-\" + id.toString()]: rotation }, { webForward: true });\r\n    }\r\n    setOnPlayerPositionUpdate(callback) {\r\n        this.onPlayerPositionUpdate = callback;\r\n    }\r\n    setOnJoinedRoom(callback) {\r\n        this.onJoinedRoom = callback;\r\n    }\r\n    onActorJoin(actor) {\r\n        // If the joining actor is the current client, no need to set its custom properties\r\n\r\n        if (this.actorJoinCallback) {\r\n            this.actorJoinCallback(actor);\r\n        }\r\n    }\r\n    onActorLeave(actor) {\r\n        if (this.actorLeaveCallback) {\r\n            this.actorLeaveCallback(actor);\r\n        }\r\n    }\r\n    setOnActorJoin(callback) {\r\n        this.actorJoinCallback = callback;\r\n    }\r\n    setOnActorLeave(callback) {\r\n        this.actorLeaveCallback = callback;\r\n    }\r\n    onEvent(code, data) {\r\n        // Handle Photon events here\r\n    if (code === 1) { // Add this\r\n            \r\n            const { id, position, rotation  } = data;\r\n\r\n\r\n            this.playerPositions.set(id, position, rotation);\r\n            this.onPlayerPositionUpdate(id,  position, rotation);\r\n\r\n        }\r\n    }\r\n    onError(errorCode, errorMsg) {\r\n        console.error(`Photon Error: ${errorCode} - ${errorMsg}`);\r\n    }\r\n    onStateChange(state) {\r\n        if (state === Photon.LoadBalancing.LoadBalancingClient.State.JoinedLobby) {\r\n            // this.joinOrCreateRoom('test');\r\n        }\r\n        else if (state === Photon.LoadBalancing.LoadBalancingClient.State.Joined) {\r\n            this.onJoinedRoom();\r\n\r\n        }\r\n    }\r\n    onRoomList(rooms) {\r\n        console.log(rooms);\r\n        this.roomList = rooms;\r\n        this.joinOrCreateRoom(\"test23\");\r\n    }\r\n    getPing() {\r\n        this.photon.updateRtt(\"test23\");\r\n        return this.photon.getRtt();\r\n    }\r\n}\n\n//# sourceURL=webpack://my-app/./src/scripts/classes/PhotonManager.js?");

/***/ }),

/***/ "./src/scripts/classes/Player.js":
/*!***************************************!*\
  !*** ./src/scripts/classes/Player.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Player\": () => (/* binding */ Player)\n/* harmony export */ });\nclass Player {\r\n  constructor(scene, id, isLocal, position = new BABYLON.Vector3(0, 0, 0), rotation=new BABYLON.Quaternion()) {\r\n    console.log(position);\r\n    this.scene = scene;\r\n    this.engine = scene.getEngine();\r\n    this.id = id;\r\n    this.isLocal = isLocal;\r\n    this.position = position;\r\n    this.rotation = rotation;\r\n    this.speed = 0.05;\r\n    this.ZERO_QUATERNION = new BABYLON.Quaternion();\r\n    this.actions = { acceleration: false, braking: false, right: false, left: false, drift: false, boost: false, special: false, special2: false, special3: false };\r\n    this.mesh = null;\r\n    this.positionUpdated=false;\r\n    this.previousState=null;\r\n    this.respawnPosition = position.clone();\r\n    this.advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n    this.specialActive = false;\r\n    this.special2Active = false;\r\n    this.engineForceMultiplier = 1;\r\n    this.lastSpecialTime = 0;\r\n    this.lastSpecial2Time = 0;\r\n    this.lastSpecial3Time = 0;\r\n    this.wheelMeshes = [];\r\n    this.init();\r\n  }\r\n  updatePhysicsBody(position, rotation) {\r\n    if (this.body) {\r\n      const ammoPosition = new Ammo.btVector3(position._x, position._y, position._z);\r\n      const ammoRotation = new Ammo.btQuaternion(rotation._x, rotation._y, rotation._z, rotation._w);\r\n      const ammoTransform = new Ammo.btTransform();\r\n      ammoTransform.setIdentity();\r\n      ammoTransform.setOrigin(ammoPosition);\r\n      ammoTransform.setRotation(ammoRotation);\r\n      this.body.setWorldTransform(ammoTransform);\r\n      this.body.setMotionState(new Ammo.btDefaultMotionState(ammoTransform));\r\n\r\n    //   this.mesh.position.copyFrom(position);\r\n    // this.mesh.rotationQuaternion.copyFrom(rotation);\r\n    } else {\r\n      console.warn(`Attempted to update physics body for player ${this.id} but body is not initialized`);\r\n    }\r\n  }\r\n  updatePhysicsBodyRotation(rotation) {\r\n    if (this.body) {\r\n      const ammoRotation = new Ammo.btQuaternion(rotation.x, rotation.y, rotation.z, rotation.w);\r\n      const ammoTransform = this.body.getCenterOfMassTransform();\r\n      ammoTransform.setRotation(ammoRotation);\r\n      this.body.setCenterOfMassTransform(ammoTransform);\r\n    } else {\r\n      console.warn(`Attempted to update physics body rotation for player ${this.id} but body is not initialized`);\r\n    }\r\n  }\r\n  init() {\r\n    this.mesh = this.createVehicle(this.position, this.rotation);\r\n    this.mesh.position = this.position;\r\n    this.mesh.rotationQuaternion = this.rotation;\r\n    this.positionUpdated = false;\r\n    this.boostParticles = this.createBoostParticles();\r\n    console.log(\"player \" + this.id + \" created\");\r\n    if (this.isLocal) {\r\n      if (/Mobi|Android/i.test(navigator.userAgent)) {\r\n        // Mobile device detected\r\n        this.createJoystick();\r\n        this.createButtons();\r\n        this.setupControls();\r\n      }\r\n      this.createButtons();\r\n      this.createJoystick();\r\n      this.setupControls();\r\n    }\r\n    else {\r\n     // this.mesh.physicsImpostor.setMass(400);\r\n\r\n    }\r\n    var box = new BABYLON.MeshBuilder.CreateBox(\"box\", {width:1, depth:1, height:1}, this.scene);\r\n    box.position.set(1,1,1);\r\n    box.rotation.set(1,1,1);\r\n\r\n        box.position.y += 5;\r\n\r\n    box.physicsImpostor = new BABYLON.PhysicsImpostor(box, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, friction: 0.5, restitution: 0.7 }, this.scene);\r\n    this.mesh.setOr\r\n    return this.mesh;\r\n  }\r\n  \r\n  createJoystick() {\r\n    const joystickContainer = document.createElement(\"div\");\r\n    joystickContainer.style.position = \"absolute\";\r\n    joystickContainer.style.bottom = \"0px\";\r\n    joystickContainer.style.left = \"0px\";\r\n    joystickContainer.style.width = \"50%\";\r\n    joystickContainer.style.height = \"70%\";\r\n    //user select none.\r\n    joystickContainer.style.webkitUserSelect = \"none\";\r\n    joystickContainer.style.mozUserSelect = \"none\";\r\n    joystickContainer.style.msUserSelect = \"none\";\r\n    joystickContainer.style.userSelect = \"none\";\r\n    document.body.appendChild(joystickContainer);\r\n  \r\n    this.joystick = nipplejs.create({\r\n      zone: joystickContainer,\r\n      mode: 'dynamic',\r\n      position: { left: '75%', top: '50%' },\r\n      size: 100,\r\n      color: 'white',\r\n    });\r\n  \r\n    this.joystick.on('move', (event, data) => {\r\n      const angle = data.angle.degree;\r\n  \r\n      this.actions.acceleration = false;\r\n      this.actions.braking = false;\r\n      this.actions.right = false;\r\n      this.actions.left = false;\r\n  \r\n      if (angle >= 10 && angle < 70) {\r\n        this.actions.acceleration |= true;\r\n        this.actions.right |= true;\r\n      } else if (angle >= 110 && angle < 170) {\r\n        this.actions.acceleration |= true;\r\n        this.actions.left |= true;\r\n      } else if (angle >= 70 && angle < 110) {\r\n        this.actions.acceleration |= true;\r\n      }\r\n  \r\n      if (angle >= 235 && angle < 255) {\r\n        this.actions.braking |= true;\r\n        this.actions.left |= true;\r\n      } else if (angle >= 285 && angle < 310) {\r\n        this.actions.braking |= true;\r\n        this.actions.right |= true;\r\n      } else if (angle >= 255 && angle < 285) {\r\n        this.actions.braking |= true;\r\n      }\r\n  \r\n      if (angle >= 0 && angle < 10 || angle >= 310 && angle < 360) {\r\n        this.actions.right |= true;\r\n      }\r\n  \r\n      if (angle >= 170 && angle < 235) {\r\n        this.actions.left |= true;\r\n      }\r\n    });\r\n    \r\n    this.joystick.on('end', () => {\r\n      this.actions.acceleration = false;\r\n      this.actions.braking = false;\r\n      this.actions.right = false;\r\n      this.actions.left = false;\r\n      this.actions.up = false;\r\n      this.actions.down = false;\r\n    });\r\n  }\r\n  \r\n\r\n  createButtons() {\r\n    // Create braking button\r\n    const brakingButton = BABYLON.GUI.Button.CreateSimpleButton(\"brakingButton\", \"Brake\");\r\n    brakingButton.width = \"250px\";\r\n    brakingButton.height = \"125px\";\r\n    brakingButton.color = \"white\";\r\n    brakingButton.background = \"black\";\r\n    brakingButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    brakingButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    brakingButton.paddingRight = \"10px\";\r\n    brakingButton.paddingBottom = \"10px\";\r\n    brakingButton.top = \"-50px\";\r\n    brakingButton.textBlock.fontSize = 40;\r\n    this.advancedTexture.addControl(brakingButton);\r\n\r\n    brakingButton.onPointerDownObservable.add(() => {\r\n      this.actions.drift = true;\r\n    });\r\n\r\n    brakingButton.onPointerUpObservable.add(() => {\r\n      this.actions.drift = false;\r\n    });\r\n\r\n    // Create boost button\r\n    const boostButton = BABYLON.GUI.Button.CreateSimpleButton(\"boostButton\", \"Boost\");\r\n    boostButton.width = \"250px\";\r\n    boostButton.height = \"125px\";\r\n    boostButton.color = \"white\";\r\n    boostButton.background = \"black\";\r\n    boostButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    boostButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    boostButton.paddingRight = \"10px\";\r\n    boostButton.paddingBottom = \"10px\";\r\n    boostButton.top = \"-190px\"; // Set the initial position of the boost button\r\n    boostButton.textBlock.fontSize = 40;\r\n    this.advancedTexture.addControl(boostButton);\r\n\r\n    boostButton.onPointerDownObservable.add(() => {\r\n      this.actions.boost = true;\r\n    });\r\n\r\n    boostButton.onPointerUpObservable.add(() => {\r\n      this.actions.boost = false;\r\n    });\r\n\r\n    const specialButton = BABYLON.GUI.Button.CreateSimpleButton(\"specialButton\", \"Special\");\r\n    specialButton.width = \"250px\";\r\n    specialButton.height = \"125px\";\r\n    specialButton.color = \"white\";\r\n    specialButton.background = \"black\";\r\n    specialButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    specialButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    specialButton.paddingRight = \"10px\";\r\n    specialButton.paddingBottom = \"10px\";\r\n    specialButton.top = \"-330px\"; // Set the initial position of the boost button\r\n    specialButton.textBlock.fontSize = 40;\r\n    this.advancedTexture.addControl(specialButton);\r\n\r\n    specialButton.onPointerDownObservable.add(() => {\r\n      const currentTime = Date.now();\r\n      if (currentTime - this.lastSpecialTime >= 5000) {\r\n        this.actions.special = true;\r\n        this.lastSpecialTime = currentTime;\r\n    \r\n        // Reset the height of the specialFill rectangle\r\n        specialFill.height = \"125px\";\r\n        this.advancedTexture.addControl(specialFill);\r\n      }\r\n    });\r\n\r\n    specialButton.onPointerUpObservable.add(() => {\r\n      this.actions.special = false;\r\n    });\r\n\r\n    const special2Button = BABYLON.GUI.Button.CreateSimpleButton(\"special2Button\", \"Special2\");\r\n    special2Button.width = \"250px\";\r\n    special2Button.height = \"125px\";\r\n    special2Button.color = \"white\";\r\n    special2Button.background = \"black\";\r\n    special2Button.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    special2Button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    special2Button.paddingRight = \"10px\";\r\n    special2Button.paddingBottom = \"10px\";\r\n    special2Button.top = \"-470px\"; // Set the initial position of the boost button\r\n    special2Button.textBlock.fontSize = 40;\r\n    this.advancedTexture.addControl(special2Button);\r\n\r\n    special2Button.onPointerDownObservable.add(() => {\r\n      const currentTime = Date.now();\r\n      if (currentTime - this.lastSpecial2Time >= 5000) {\r\n        this.actions.special2 = true;\r\n        this.lastSpecial2Time = currentTime;\r\n    \r\n        // Reset the height of the special2Fill rectangle\r\n        special2Fill.height = \"125px\";\r\n        this.advancedTexture.addControl(special2Fill);\r\n      }\r\n    });\r\n\r\n    special2Button.onPointerUpObservable.add(() => {\r\n      this.actions.special2 = false;\r\n    });\r\n\r\n    const special3Button = BABYLON.GUI.Button.CreateSimpleButton(\"special3Button\", \"Special3\");\r\n    special3Button.width = \"250px\";\r\n    special3Button.height = \"125px\";\r\n    special3Button.color = \"white\";\r\n    special3Button.background = \"black\";\r\n    special3Button.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    special3Button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    special3Button.paddingRight = \"10px\";\r\n    special3Button.paddingBottom = \"10px\";\r\n    special3Button.top = \"-610px\"; // Set the initial position of the boost button\r\n    special3Button.textBlock.fontSize = 40;\r\n    this.advancedTexture.addControl(special3Button);\r\n\r\n    special3Button.onPointerDownObservable.add(() => {\r\n      const currentTime = Date.now();\r\n      if (currentTime - this.lastSpecial3Time >= 5000) {\r\n        this.actions.special3 = true;\r\n        this.lastSpecial3Time = currentTime;\r\n    \r\n        // Reset the height of the special3Fill rectangle\r\n        special3Fill.height = \"125px\";\r\n        this.advancedTexture.addControl(special3Fill);\r\n      }\r\n    });\r\n\r\n    special3Button.onPointerUpObservable.add(() => {\r\n      this.actions.special3 = false;\r\n    });\r\n\r\n    // Special Button filling effect\r\n    const specialFill = new BABYLON.GUI.Rectangle();\r\n    specialFill.width = \"250px\";\r\n    specialFill.height = \"0px\";\r\n    specialFill.color = \"white\";\r\n    specialFill.background = \"green\";\r\n    specialFill.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    specialFill.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    specialFill.paddingRight = \"10px\";\r\n    specialFill.paddingBottom = \"10px\";\r\n    specialFill.top = \"-330px\"; // Set the initial position of the special fill\r\n    this.advancedTexture.addControl(specialFill);\r\n\r\n    // Special2 Button filling effect\r\n    const special2Fill = new BABYLON.GUI.Rectangle();\r\n    special2Fill.width = \"250px\";\r\n    special2Fill.height = \"0px\";\r\n    special2Fill.color = \"white\";\r\n    special2Fill.background = \"green\";\r\n    special2Fill.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    special2Fill.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    special2Fill.paddingRight = \"10px\";\r\n    special2Fill.paddingBottom = \"10px\";\r\n    special2Fill.top = \"-470px\"; // Set the initial position of the special2 fill\r\n    this.advancedTexture.addControl(special2Fill);\r\n\r\n    // Special3 Button filling effect\r\n    const special3Fill = new BABYLON.GUI.Rectangle();\r\n    special3Fill.width = \"250px\";\r\n    special3Fill.height = \"0px\";\r\n    special3Fill.color = \"white\";\r\n    special3Fill.background = \"green\";\r\n    special3Fill.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    special3Fill.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    special3Fill.paddingRight = \"10px\";\r\n    special3Fill.paddingBottom = \"10px\";\r\n    special3Fill.top = \"-610px\"; // Set the initial position of the special3 fill\r\n    this.advancedTexture.addControl(special3Fill);\r\n\r\n    // Update the height of the filling rectangles and button states\r\n    const updateFillingHeight = () => {\r\n      const currentTime = Date.now();\r\n\r\n      const specialElapsedTime = (currentTime - this.lastSpecialTime) / 5000;\r\n      const specialHeight = Math.max(0, 125 - specialElapsedTime * 125);\r\n      specialFill.height = specialHeight + \"px\";\r\n      specialButton.background = specialElapsedTime >= 1 ? \"black\" : \"gray\";\r\n      specialButton.isHitTestVisible = specialElapsedTime >= 1;\r\n\r\n      const special2ElapsedTime = (currentTime - this.lastSpecial2Time) / 5000;\r\n      const special2Height = Math.max(0, 125 - special2ElapsedTime * 125);\r\n      special2Fill.height = special2Height + \"px\";\r\n      special2Button.background = special2ElapsedTime >= 1 ? \"black\" : \"gray\";\r\n      special2Button.isHitTestVisible = special2ElapsedTime >= 1;\r\n\r\n      const special3ElapsedTime = (currentTime - this.lastSpecial3Time) / 5000;\r\n      const special3Height = Math.max(0, 125 - special3ElapsedTime * 125);\r\n      special3Fill.height = special3Height + \"px\";\r\n      special3Button.background = special3ElapsedTime >= 1 ? \"black\" : \"gray\";\r\n      special3Button.isHitTestVisible = special3ElapsedTime >= 1;\r\n\r\n      // Schedule the next update\r\n      setTimeout(updateFillingHeight, 50);\r\n    };\r\n\r\n    // Start the update loop\r\n    updateFillingHeight();\r\n  }\r\n\r\n  respawn() {\r\n    var transform = new Ammo.btTransform();\r\n    transform.setIdentity();\r\n    transform.setOrigin(new Ammo.btVector3(0, 0, 0));\r\n    transform.setRotation(new Ammo.btQuaternion(0, 0, 0, 1));\r\n    this.body.setCenterOfMassTransform(transform);\r\n    this.body.setLinearVelocity(new Ammo.btVector3(0, 0, 0));\r\n    this.body.setAngularVelocity(new Ammo.btVector3(0, 0, 0));\r\n    this.body.activate();\r\n  }\r\n\r\n  createBoostParticles() {\r\n    const particleSystem = new BABYLON.ParticleSystem(\"particles\", 2000, this.scene);\r\n    particleSystem.particleTexture = new BABYLON.Texture(\"../textures/boost.png\", this.scene);\r\n    particleSystem.emitter = this.mesh;\r\n    particleSystem.minEmitBox = new BABYLON.Vector3(-0.5, 0, 2);\r\n    particleSystem.maxEmitBox = new BABYLON.Vector3(0.5, 0, 2);\r\n\r\n    particleSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0.5);\r\n    particleSystem.minSize = 0.1;\r\n    particleSystem.maxSize = 0.3;\r\n    particleSystem.minLifeTime = 0.1;\r\n    particleSystem.maxLifeTime = 0.11;\r\n    particleSystem.emitRate = 2000;\r\n    particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;\r\n    particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);\r\n    particleSystem.direction1 = new BABYLON.Vector3(0, 0, 2);\r\n    particleSystem.direction2 = new BABYLON.Vector3(0, 0, 2);\r\n    particleSystem.minEmitPower = 1;\r\n    particleSystem.maxEmitPower = 3;\r\n    particleSystem.updateSpeed = 0.005;\r\n  \r\n    return particleSystem;\r\n  }\r\n\r\n  createVehicle(pos, quat) {\r\n    const addWheel = (isFront, pos, radius, width, index) => {\r\n\r\n      var wheelInfo = vehicle.addWheel(\r\n        pos,\r\n        wheelDirectionCS0,\r\n        wheelAxleCS,\r\n        suspensionRestLength,\r\n        radius,\r\n        tuning,\r\n        isFront);\r\n        if (!isFront) {\r\n          wheelInfo.set_m_frictionSlip(driftFriction);\r\n        }\r\n      wheelInfo.set_m_suspensionStiffness(suspensionStiffness);\r\n      wheelInfo.set_m_wheelsDampingRelaxation(suspensionDamping);\r\n      wheelInfo.set_m_wheelsDampingCompression(suspensionCompression);\r\n      wheelInfo.set_m_maxSuspensionForce(600000);\r\n      wheelInfo.set_m_frictionSlip(20);\r\n      wheelInfo.set_m_rollInfluence(rollInfluence);\r\n\r\n      var wheelMaterial = new BABYLON.StandardMaterial(\"wheelMaterial\");\r\n      wheelMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);\r\n    \r\n      this.wheelMeshes[index] = createWheelMesh(radius, width);\r\n      if (isFront) {\r\n        var wheelMaterial = new BABYLON.StandardMaterial(\"wheelMaterial\");\r\n        wheelMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);\r\n        this.wheelMeshes[index].material = wheelMaterial;\r\n      }\r\n    }\r\n\r\n    function createWheelMesh(radius, width) {\r\n      //var mesh = new BABYLON.MeshBuilder.CreateBox(\"wheel\", {width:.82, height:.82, depth:.82});\r\n      var mesh = new BABYLON.MeshBuilder.CreateCylinder(\"Wheel\", { diameter: 1.5, height: 0.8, tessellation: 12 });\r\n      mesh.rotationQuaternion = new BABYLON.Quaternion();\r\n      return mesh;\r\n    }\r\n\r\n    function createChassisMesh(w, l, h) {\r\n      var mesh = new BABYLON.MeshBuilder.CreateBox(\"box\", { width: w, depth: h, height: l });\r\n      mesh.rotationQuaternion = new BABYLON.Quaternion();\r\n      return mesh;\r\n    }\r\n\r\n    var vehicle, chassisMesh;\r\n    \r\n\r\n    var vehicleReady = false;\r\n\r\n    var chassisWidth = 1.8;\r\n    var chassisHeight = .6;\r\n    var chassisLength = 4;\r\n    var massVehicle = 400;//200\r\n\r\n    var wheelAxisPositionBack = -2;\r\n    var wheelRadiusBack = .8;\r\n    var wheelWidthBack = .6;\r\n    var wheelHalfTrackBack = 1.5;\r\n    var wheelAxisHeightBack = 0.4;\r\n\r\n    var wheelAxisFrontPosition = 2.0;\r\n    var wheelHalfTrackFront = 1.5;\r\n    var wheelAxisHeightFront = 0.4;\r\n    var wheelRadiusFront = .8;\r\n    var wheelWidthFront = .6;\r\n\r\n    var friction = 5;\r\n    var suspensionStiffness = 20;\r\n    var suspensionDamping = 1;\r\n    var suspensionCompression = 2;\r\n    var suspensionRestLength = 0.6;\r\n    var rollInfluence = -0.2;\r\n\r\n    var steeringIncrement = .01;\r\n    var steeringClamp = 0.4;\r\n    var maxEngineForce = 3000;\r\n    var maxBreakingForce = 20;\r\n    var incEngine = 10.0;\r\n    var driftBreakingForce = 7;\r\n\r\n    var FRONT_LEFT = 0;\r\n    var FRONT_RIGHT = 1;\r\n    var BACK_LEFT = 2;\r\n    var BACK_RIGHT = 3;\r\n\r\n    var driftFriction = 40;\r\n\r\n    var wheelDirectionCS0;\r\n    var wheelAxleCS;\r\n\r\n    var physicsWorld = this.scene.getPhysicsEngine().getPhysicsPlugin().world;\r\n\r\n    var wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0);\r\n    var wheelAxleCS = new Ammo.btVector3(-1, 0, 0);\r\n\r\n    var geometry = new Ammo.btBoxShape(new Ammo.btVector3(chassisWidth * 1, chassisHeight * 1, chassisLength * 0.75));\r\n    var transform = new Ammo.btTransform();\r\n    transform.setIdentity();\r\n    transform.setOrigin(new Ammo.btVector3(this.position.x, this.position.y, this.position.x));\r\n    transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));\r\n    var motionState = new Ammo.btDefaultMotionState(transform);\r\n    var localInertia = new Ammo.btVector3(0, 0, 0);\r\n    geometry.calculateLocalInertia(massVehicle, localInertia);\r\n\r\n    chassisMesh = createChassisMesh(chassisWidth * 1.5, chassisHeight * 1.5, chassisLength * 1.5);\r\n\r\n    var massOffset = new Ammo.btVector3(0, 0.4, 0);\r\n    var transform2 = new Ammo.btTransform();\r\n    transform2.setIdentity();\r\n    transform2.setOrigin(massOffset);\r\n    var compound = new Ammo.btCompoundShape();\r\n    compound.addChildShape(transform2, geometry);\r\n    compound.position = this.position;\r\n    var body = new Ammo.btRigidBody(new Ammo.btRigidBodyConstructionInfo(massVehicle, motionState, compound, localInertia));\r\n    body.setActivationState(4);\r\n\r\n    this.body = body;\r\n\r\n    physicsWorld.addRigidBody(body);\r\n\r\n    var engineForce = 0;\r\n    var vehicleSteering = 0;\r\n    var breakingForce = 0;\r\n    var tuning = new Ammo.btVehicleTuning();\r\n    var rayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld);\r\n    vehicle = new Ammo.btRaycastVehicle(tuning, body, rayCaster);\r\n    vehicle.setCoordinateSystem(0, 1, 2);\r\n    physicsWorld.addAction(vehicle);\r\n\r\n    var trans = vehicle.getChassisWorldTransform();\r\n    trans.setOrigin(new Ammo.btVector3(this.position.x, this.position.y, this.position.z));\r\n    //vehicle.setChassisWorldTransform(trans);\r\n\r\n    addWheel(true, new Ammo.btVector3(wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_LEFT);\r\n    addWheel(true, new Ammo.btVector3(-wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisFrontPosition), wheelRadiusFront, wheelWidthFront, FRONT_RIGHT);\r\n    addWheel(false, new Ammo.btVector3(-wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_LEFT);\r\n    addWheel(false, new Ammo.btVector3(wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_RIGHT);\r\n\r\n    vehicleReady = true;\r\n\r\n    this.scene.registerBeforeRender(() => {\r\n      // var dt = this.engine.getDeltaTime().toFixed() / 1000;,\r\n\r\n      if (vehicleReady) {\r\n\r\n        var speed = vehicle.getCurrentSpeedKmHour();\r\n        var maxSteerVal = 0.2;\r\n        breakingForce = 0;\r\n        engineForce = 0;\r\n\r\n        if (this.actions.acceleration) {\r\n          if (speed < -1) {\r\n            breakingForce = maxBreakingForce;\r\n          } else {\r\n            engineForce = maxEngineForce;\r\n          }\r\n\r\n        } else if (this.actions.braking) {\r\n          if (speed > 1) {\r\n            breakingForce = maxBreakingForce;\r\n          } else {\r\n            engineForce = -maxEngineForce;\r\n          }\r\n        }\r\n\r\n        if (this.actions.right) {\r\n          if (vehicleSteering < steeringClamp) {\r\n            vehicleSteering += steeringIncrement;\r\n          }\r\n\r\n        } else if (this.actions.left) {\r\n          if (vehicleSteering > -steeringClamp) {\r\n            vehicleSteering -= steeringIncrement;\r\n          }\r\n\r\n        } else {\r\n          vehicleSteering = 0;\r\n        }\r\n\r\n        if (this.actions.drift) {\r\n          driftFriction = 5;\r\n          breakingForce += driftBreakingForce * 6;\r\n        } else {\r\n          driftFriction = 40;\r\n        }\r\n\r\n        if (this.actions.boost) {\r\n          engineForce = maxEngineForce * 1.6;\r\n          if (!this.boostParticles.isStarted()) {\r\n            this.boostParticles.start();\r\n          }\r\n        } else {\r\n          if (this.boostParticles.isStarted()) {\r\n            this.boostParticles.stop();\r\n          }\r\n        }\r\n\r\n        if(this.actions.special && !this.specialActive) {\r\n          // Mark special as active\r\n          this.specialActive = true;\r\n          this.engineForceMultiplier = 0;\r\n\r\n          // Apply a large braking force to all wheels\r\n          vehicle.setBrake(10000, FRONT_LEFT);\r\n          vehicle.setBrake(10000, FRONT_RIGHT);\r\n          vehicle.setBrake(10000, BACK_LEFT);\r\n          vehicle.setBrake(10000, BACK_RIGHT);\r\n        \r\n          // Set the car's linear and angular velocity to zero\r\n          const linearVelocity = this.body.getLinearVelocity();\r\n          linearVelocity.setValue(0, 0, 0);\r\n          this.body.setLinearVelocity(linearVelocity);\r\n        \r\n          const angularVelocity = this.body.getAngularVelocity();\r\n          angularVelocity.setValue(0, 0, 0);\r\n          this.body.setAngularVelocity(angularVelocity);\r\n        \r\n          // Set a timer to release the brakes and restore the car's control after 2 seconds\r\n          setTimeout(() => {\r\n            vehicle.setBrake(0, FRONT_LEFT);\r\n            vehicle.setBrake(0, FRONT_RIGHT);\r\n            vehicle.setBrake(0, BACK_LEFT);\r\n            vehicle.setBrake(0, BACK_RIGHT);\r\n        \r\n            // Mark special as inactive\r\n            this.specialActive = false;\r\n            this.engineForceMultiplier = 1;\r\n          }, 2000);\r\n        }        \r\n\r\n        if(this.actions.special2 && !this.special2Active) {\r\n          // Mark special2 as active\r\n          this.special2Active = true;\r\n        \r\n          // Increase the car's mass by a factor of 10\r\n          const massFactor = 10;\r\n          const originalMass = massVehicle;\r\n          const increasedMass = originalMass * massFactor;\r\n          this.body.setMassProps(increasedMass, localInertia);\r\n        \r\n          // Set the car's linear and angular velocity to zero\r\n          const linearVelocity = this.body.getLinearVelocity();\r\n          linearVelocity.setValue(0, 0, 0);\r\n          this.body.setLinearVelocity(linearVelocity);\r\n        \r\n          const angularVelocity = this.body.getAngularVelocity();\r\n          angularVelocity.setValue(0, 0, 0);\r\n          this.body.setAngularVelocity(angularVelocity);\r\n        \r\n          // Set a timer to reset the mass after 2 seconds\r\n          setTimeout(() => {\r\n            // Reset the car's mass to the original value\r\n            this.body.setMassProps(originalMass, localInertia);\r\n          \r\n            // Release the brakes after a short delay\r\n            setTimeout(() => {\r\n              vehicle.setBrake(0, FRONT_LEFT);\r\n              vehicle.setBrake(0, FRONT_RIGHT);\r\n              vehicle.setBrake(0, BACK_LEFT);\r\n              vehicle.setBrake(0, BACK_RIGHT);\r\n          \r\n              // Mark special2 as inactive\r\n              this.special2Active = false;\r\n            }, 200);\r\n          }, 2000);\r\n          \r\n        }\r\n        \r\n        if (this.actions.special3 && !this.special3Active) {\r\n          // Mark special3 as active\r\n          this.special3Active = true;\r\n      \r\n          // Calculate the current speed and movement direction\r\n          const speed = vehicle.getCurrentSpeedKmHour() / 3.6;\r\n          const movementDirection = vehicle.getForwardVector();\r\n      \r\n          // Calculate the extra force for the quick dash\r\n          const dashForce = 50000;\r\n      \r\n          // Apply the dash force to the vehicle\r\n          const impulse = new Ammo.btVector3(movementDirection.x() * dashForce, 0, movementDirection.z() * dashForce);\r\n          this.body.applyCentralImpulse(impulse);\r\n      \r\n          // Set a timer to mark special3 as inactive after a short delay\r\n          setTimeout(() => {\r\n            this.special3Active = false;\r\n            const stopImpulse = new Ammo.btVector3(0, 0, 0);\r\n            this.body.setLinearVelocity(stopImpulse);\r\n          }, 200);\r\n\r\n        }\r\n        \r\n        vehicle.getWheelInfo(BACK_LEFT).set_m_frictionSlip(driftFriction / 1.1);\r\n        vehicle.getWheelInfo(BACK_RIGHT).set_m_frictionSlip(driftFriction / 1.1);\r\n        vehicle.getWheelInfo(FRONT_LEFT).set_m_frictionSlip(driftFriction);\r\n        vehicle.getWheelInfo(FRONT_RIGHT).set_m_frictionSlip(driftFriction);\r\n        \r\n        vehicle.applyEngineForce(engineForce * this.engineForceMultiplier, FRONT_LEFT);\r\n        vehicle.applyEngineForce(engineForce * this.engineForceMultiplier, FRONT_RIGHT);\r\n\r\n        vehicle.setBrake(breakingForce / 2, FRONT_LEFT);\r\n        vehicle.setBrake(breakingForce / 2, FRONT_RIGHT);\r\n        vehicle.setBrake(breakingForce, BACK_LEFT);\r\n        vehicle.setBrake(breakingForce, BACK_RIGHT);\r\n\r\n        vehicle.setSteeringValue(vehicleSteering, FRONT_LEFT);\r\n        vehicle.setSteeringValue(vehicleSteering, FRONT_RIGHT);\r\n\r\n        var tm, p, q, i;\r\n        var n = vehicle.getNumWheels();\r\n        for (i = 0; i < n; i++) {\r\n          vehicle.updateWheelTransform(i, true);\r\n          tm = vehicle.getWheelTransformWS(i);\r\n          p = tm.getOrigin();\r\n          q = tm.getRotation();\r\n          this.wheelMeshes[i].position.set(p.x(), p.y(), p.z());\r\n          this.wheelMeshes[i].rotationQuaternion.set(q.x(), q.y(), q.z(), q.w());\r\n          this.wheelMeshes[i].rotate(BABYLON.Axis.Z, Math.PI / 2);\r\n        }\r\n\r\n        tm = vehicle.getChassisWorldTransform();\r\n        p = tm.getOrigin();\r\n        q = tm.getRotation();\r\n        chassisMesh.position.set(p.x(), p.y(), p.z());\r\n        chassisMesh.rotationQuaternion.set(q.x(), q.y(), q.z(), q.w());\r\n        \r\n        //chassisMesh.rotate(BABYLON.Axis.X, Math.PI);\r\n      }\r\n      if (chassisMesh.position.y < -5) {\r\n        this.respawn();\r\n      }\r\n    });\r\n\r\n    \r\n    return chassisMesh  ;\r\n  }\r\n\r\n  setupControls() {\r\n\r\n  }  \r\n\r\n  moveForward() {\r\n    this.mesh.position.z -= this.speed;\r\n  }\r\n\r\n  moveBackward() {\r\n    this.mesh.position.z += this.speed;\r\n  }\r\n\r\n  moveLeft() {\r\n    this.mesh.position.x -= this.speed;\r\n  }\r\n\r\n  moveRight() {\r\n    this.mesh.position.x += this.speed;\r\n  }\r\n\r\n  updatePosition(position) {\r\n    this.mesh.position = position;\r\n  }\r\n\r\n  destroy() {\r\n    if (this.mesh) {\r\n      this.wheelMeshes.forEach((wheelMesh) => {wheelMesh.dispose()});\r\n      this.mesh.dispose();\r\n      \r\n      if(this.isLocal)\r\n        this.scene.getPhysicsEngine().removeAction(this.vehicle);\r\n      \r\n      console.log(`Player ${this.id} destroyed`);\r\n    } else {\r\n      console.warn(`Attempted to destroy player ${this.id} but mesh is not initialized`);\r\n    }\r\n  }\r\n}\n\n//# sourceURL=webpack://my-app/./src/scripts/classes/Player.js?");

/***/ }),

/***/ "./src/scripts/scenes/game2.js":
/*!*************************************!*\
  !*** ./src/scripts/scenes/game2.js ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _classes_Player_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/Player.js */ \"./src/scripts/classes/Player.js\");\n/* harmony import */ var _classes_PhotonManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/PhotonManager.js */ \"./src/scripts/classes/PhotonManager.js\");\n// Import the classes\r\n\r\n\r\n\r\n// Create the Babylon.js engine and scene\r\nconst canvas = document.getElementById('renderCanvas');\r\nconst engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, adaptToDeviceRatio: true });\r\nconst scene = new BABYLON.Scene(engine);\r\n\r\nlet divFps = document.getElementById(\"debug\");\r\nlet ping = 0;\r\n\r\nawait Ammo();\r\n\r\nscene.enablePhysics(new BABYLON.Vector3(0, -20, 0), new BABYLON.AmmoJSPlugin(true, Ammo));\r\n\r\n\r\nlet localPlayer = null;\r\nscene.clearColor = new BABYLON.Color3(0.8, 0.8, 0.8);\r\n\r\nconst groundRadius = 45;\r\nconst ground = BABYLON.MeshBuilder.CreateDisc('ground', { radius: groundRadius, tessellation: 64 }, scene);\r\nconst groundMaterial = new BABYLON.GridMaterial('groundMaterial', scene);\r\ngroundMaterial.mainColor = new BABYLON.Color3(0.4, 0.4, 0.4);\r\ngroundMaterial.lineColor = new BABYLON.Color3(0.2, 0.2, 0.2);\r\nground.material = groundMaterial;\r\n\r\nground.position.z = -1;\r\n\r\nconst groundPhysicsOptions = {\r\n  mass: 0,\r\n  friction: 0.5,\r\n  restitution: 0.7,\r\n  shape: BABYLON.PhysicsImpostor.CylinderImpostor,\r\n  nativeOptions: {\r\n    radiusTop: groundRadius,\r\n    radiusBottom: groundRadius,\r\n    height: 0.01,\r\n    numSegments: 64,\r\n    mass: 0\r\n  }\r\n};\r\nground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.MeshImpostor, groundPhysicsOptions, scene);\r\n\r\nground.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);\r\n\r\nconst camera = new BABYLON.ArcRotateCamera(\"camera1\", Math.PI / 2, 2.1, -24, new BABYLON.Vector3(0, 0, 0), scene);\r\ncamera.setPosition(new BABYLON.Vector3(0, 35, 65));\r\ncamera.setTarget(new BABYLON.Vector3(0, 0, 20));\r\ncamera.fov = 0.9;\r\n\r\n//camera.attachControl(canvas, true);\r\ncamera.inputs.removeByType(\"ArcRotateCameraKeyboardMoveInput\");\r\ncamera.inputs.removeByType(\"ArcRotateCameraMouseWheelInput\");\r\ncamera.inputs.removeByType(\"ArcRotateCameraPointersInput\");\r\n\r\nconst light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);\r\nconst players = new Map();\r\n\r\nconst photonManager = new _classes_PhotonManager_js__WEBPACK_IMPORTED_MODULE_1__.PhotonManager();\r\nphotonManager.setOnJoinedRoom(() => {\r\n  // Add the local player\r\n  localPlayer = new _classes_Player_js__WEBPACK_IMPORTED_MODULE_0__.Player(scene, photonManager.photon.myActor().actorNr, true, new BABYLON.Vector3(0, 0, 0));\r\n  players.set(photonManager.photon.myActor().actorNr.toString(), localPlayer);\r\n\r\n  const otherActors = photonManager.photon.myRoomActors();\r\n  console.log(otherActors);\r\n\r\n  window.addEventListener('keydown', keydown);\r\n  window.addEventListener('keyup', keyup);\r\n\r\n  console.log(\"my actor nr \" + photonManager.photon.myActor().actorNr);\r\n  for (var i = 1; i <= otherActors.length; i++) {\r\n    console.log(otherActors[i].actorNr);\r\n  }\r\n\r\n  for (var actor in otherActors) {\r\n    if (actor.toString() !== photonManager.photon.myActor().actorNr.toString()) {\r\n      const cp = photonManager.photon.myRoom().getCustomProperties();\r\n      for (const id in cp) {\r\n        if (id == \"pos-\" + actor.toString()) {\r\n          var otherPlayerPosition = cp[id];\r\n          var otherPlayerRotation = cp[\"rot-\" + actor.toString()];\r\n          break;\r\n        }\r\n      }\r\n      // Create the other player using their last known position\r\n      const otherPlayer = new _classes_Player_js__WEBPACK_IMPORTED_MODULE_0__.Player(scene, actor, false, new BABYLON.Vector3(otherPlayerPosition._x, otherPlayerPosition._y, otherPlayerPosition._z), new BABYLON.Quaternion(otherPlayerRotation._w, otherPlayerRotation._x, otherPlayerRotation._y, otherPlayerRotation._z));\r\n      console.log(otherPlayer);\r\n      players.set(actor.toString(), otherPlayer);\r\n    }\r\n  }\r\n});\r\n\r\nphotonManager.setOnActorJoin((actor) => {\r\n\r\n  console.log(\"actor joined \" + photonManager.photon.myActor().actorNr + \" \" + actor.actorNr);\r\n  if (photonManager.photon.myActor().actorNr === actor.actorNr) {\r\n    return;\r\n  }\r\n\r\n\r\n  const newposition= new BABYLON.Vector3(0, 0, 0);\r\n  const newrotation=new BABYLON.Quaternion();\r\n\r\n// Check if there is an existing player with the same actor number\r\nconst existingPlayer = photonManager.playerPositions.get(actor.actorNr.toString());\r\nif (existingPlayer) {\r\n  newposition._x = existingPlayer.x;\r\n  newposition._y = existingPlayer.y;\r\n  newposition._z = existingPlayer.z;\r\n    newrotation._w = existingPlayer.w;\r\n    newrotation._x = existingPlayer.x;\r\n    newrotation._y = existingPlayer.y;\r\n    newrotation._z = existingPlayer.z;\r\n}\r\n\r\n\r\n// Set the custom properties for the joining actor\r\nphotonManager.photon.myRoom().setCustomProperties({ [`pos-${actor.actorNr}`]: newposition, [`rot-${actor.actorNr}`]: newrotation }, { webForward: true });\r\n\r\n  const newPlayer = new _classes_Player_js__WEBPACK_IMPORTED_MODULE_0__.Player(scene, actor.actorNr, false,newposition,newrotation);\r\n  players.set(actor.actorNr.toString(), newPlayer);\r\n  console.log(\"new player joined\" + actor);\r\n});\r\n\r\nphotonManager.setOnActorLeave((actor) => {\r\n  const playerToRemove = players.get(actor.actorNr.toString());\r\n  console.log(actor)\r\n  console.log(playerToRemove)\r\n  if (playerToRemove) {\r\n    playerToRemove.destroy();\r\n    players.delete(actor);\r\n  }\r\n});\r\nphotonManager.connect();\r\n\r\nsetInterval(() => {\r\n  ping = photonManager.getPing();\r\n}, 1000);\r\n\r\n// Set up the main game loop\r\nengine.runRenderLoop(() => {\r\n  if (localPlayer != null) {\r\n    const position = localPlayer.mesh.position;\r\n    const rotation = localPlayer.mesh.rotationQuaternion;\r\n    const data = { id: photonManager.photon.myActor().actorNr, actions: localPlayer.actions, position: position, rotation: rotation };\r\n\r\n    //photonManager.photon.myRoom().setCustomProperty(\"pos-\" + photonManager.photon.myActor().actorNr.toString(), position);\r\n  //  photonManager.sendPlayerPositionUpdate(photonManager.photon.myActor().actorNr, position, rotation);\r\n   // photonManager.photon.raiseEvent(Photon.LoadBalancing.Constants.EventCode.UserCustom, data);\r\n  }\r\n\r\n  divFps.innerHTML = engine.getFps().toFixed() + \" fps\";\r\n  divFps.innerHTML += \"<br/>\" + `${ping} ms`;\r\n\r\n  scene.render();\r\n});\r\n\r\nphotonManager.setOnPlayerPositionUpdate((id,  position, rotation) => {\r\n  \r\n  if (id.toString() == photonManager.photon.myActor().actorNr.toString()) return;\r\n\r\n  photonManager.playerPositions.set(id.toString(), { position: position, rotation: rotation, timestamp: Date.now() });\r\n\r\n  const otherPlayer = players.get(id.toString());\r\n\r\n  // Interpolation\r\n  const interpolate = (start, end, t) => {\r\n    var newstart = new BABYLON.Vector3(start._x, start._y, start._z);\r\n    return BABYLON.Vector3.Lerp(newstart, end, t);\r\n  };\r\n\r\n  const interpolateRotation = (start, end, t) => {\r\n    return BABYLON.Quaternion.Slerp(start, end, t);\r\n  };\r\n\r\n  const interpolatePlayer = (player, newPosition, newRotation, interpolationTime) => {\r\n    const currentTime = Date.now();\r\n    const previousState = player.previousState;\r\n    const targetState = { position: newPosition, rotation: newRotation, timestamp: currentTime };\r\n\r\n    if (previousState) {\r\n      const deltaTime = currentTime - previousState.timestamp;\r\n      const t = Math.min(deltaTime / interpolationTime, 1);\r\n      const interpolatedPosition = interpolate(previousState.position, targetState.position, t);\r\n      const interpolatedRotation = interpolateRotation(previousState.rotation, targetState.rotation, t);\r\n\r\n      player.updatePhysicsBody(interpolatedPosition, interpolatedRotation);\r\n    } else {\r\n      player.updatePhysicsBody(newPosition, newRotation);\r\n    }\r\n  };\r\n  // Client-side prediction\r\n  if (otherPlayer) {\r\n    const newPosition = new BABYLON.Vector3(position._x, position._y, position._z);\r\n    const newRotation = new BABYLON.Quaternion(rotation._x, rotation._y, rotation._z, rotation._w);\r\n    const interpolationTime = 100; // Adjust this value to control the interpolation speed\r\n\r\n    interpolatePlayer(otherPlayer, newPosition, newRotation, interpolationTime);\r\n  }\r\n});\r\n\r\nvar keysActions = {\r\n  \"KeyW\": 'acceleration',\r\n  \"KeyS\": 'braking',\r\n  \"KeyA\": 'left',\r\n  \"KeyD\": 'right',\r\n  \"Space\": 'drift',\r\n  \"ShiftLeft\": 'boost',\r\n  \"KeyE\": 'special',\r\n  \"KeyR\": 'special2',\r\n  \"KeyQ\": 'special3',\r\n};\r\n\r\nfunction keydown(e) {\r\n  if (keysActions[e.code]) {\r\n    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {\r\n      localPlayer.actions['boost'] = true;\r\n    } else {\r\n      localPlayer.actions[keysActions[e.code]] = true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction keyup(e) {\r\n  if (keysActions[e.code]) {\r\n    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {\r\n      localPlayer.actions['boost'] = false;\r\n    } else {\r\n      localPlayer.actions[keysActions[e.code]] = false;\r\n    }\r\n  }\r\n}\r\n\r\n// Handle window resizing\r\nwindow.addEventListener('resize', () => {\r\n  engine.resize();\r\n});\r\n\r\nfunction hideLoadingScreen() {\r\n  const loadingScreen = document.getElementById('loading-screen');\r\n  loadingScreen.style.display = 'none';\r\n}\r\n\r\nsetTimeout(hideLoadingScreen, 100);\r\n\r\nfunction isMobileDevice() {\r\n  return typeof window.orientation !== \"undefined\" || navigator.userAgent.indexOf(\"IEMobile\") !== -1;\r\n}\r\n\r\nfunction updateOrientation() {\r\n  if (!isMobileDevice()) return;\r\n  const orientationWarning = document.getElementById('orientation-warning');\r\n  const canvas = document.getElementById('renderCanvas');\r\n\r\n  if (window.orientation === 90 || window.orientation === -90) {\r\n    orientationWarning.style.display = 'none';\r\n    canvas.style.display = 'block';\r\n  } else {\r\n    orientationWarning.style.display = 'block';\r\n    canvas.style.display = 'none';\r\n  }\r\n\r\n  engine.resize();\r\n}\r\n\r\n// Listen for orientation changes\r\nwindow.addEventListener('orientationchange', updateOrientation);\r\n\r\n// Update the orientation when the page loads\r\nupdateOrientation();\r\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://my-app/./src/scripts/scenes/game2.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && !queue.d) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = 1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./src/scripts/classes/Player.js");
/******/ 	__webpack_require__("./src/scripts/classes/PhotonManager.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/scripts/scenes/game2.js");
/******/ 	
/******/ })()
;